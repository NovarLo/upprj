



#define _LOCAL_LED

#include "stm32f4xx_hal.h"
#include "arm_math.h"
#include "string.h"
#include "app_user.h"
#include "app_sensor.h"
#include "app_mmi.h"
//#include "app_prtc.h"
#include "app_led.h"

// SRT_PM  PM2.5&PM10  384bytes(96*32/8)
/* *****************
*   PM2.5:    ug  *
*   PM1 0:    ug  *
******************/
const uint8_t SRT_PM[] = {
/* *****************
*   PM2.5:    ug  *
******************/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x77,0x3C,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x42,0x36,0x42,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x36,0x42,0x00,
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x36,0x42,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x42,0x36,0x20,0x00,0x1A,0x00,0x00,0x00,0x00,0x00,0x63,0x7C,
0x3E,0x2A,0x20,0x00,0x26,0x00,0x00,0x00,0x00,0x00,0x42,0x22,0x02,0x2A,0x10,0x00,
0x40,0x0C,0x00,0x00,0x00,0x00,0x42,0x22,0x02,0x2A,0x08,0x00,0x40,0x0C,0x00,0x00,
0x00,0x00,0x42,0x1C,0x02,0x2A,0x04,0x00,0x42,0x00,0x00,0x00,0x00,0x00,0x42,0x02,
0x02,0x2A,0x42,0x06,0x22,0x0C,0x00,0x00,0x00,0x00,0x62,0x3C,0x07,0x6B,0x7E,0x06,
0x1C,0x0C,0x00,0x00,0x00,0x00,0xDC,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,
/* *****************
*   PM1 0:    ug  *
******************/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x77,0x08,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x42,0x36,0x0E,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x36,0x08,0x42,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x36,0x08,0x42,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x42,0x36,0x08,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x7C,
0x3E,0x2A,0x08,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x22,0x02,0x2A,0x08,0x42,
0x0C,0x00,0x00,0x00,0x00,0x00,0x42,0x22,0x02,0x2A,0x08,0x42,0x0C,0x00,0x00,0x00,
0x00,0x00,0x42,0x1C,0x02,0x2A,0x08,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x02,
0x02,0x2A,0x08,0x24,0x0C,0x00,0x00,0x00,0x00,0x00,0x62,0x3C,0x07,0x6B,0x3E,0x18,
0x0C,0x00,0x00,0x00,0x00,0x00,0xDC,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C
};

// SRT_TH Temperature&Humidity 384Bytes(96*32/8)

/* *****************
*   温 度:    ℃  *
*   湿 度:    ％  *
******************/
const uint8_t SRT_TH[] = {
// 温度:     ℃
0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0xC4,0x1F,0x00,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x89,0x2F,0x48,0x10,0xFC,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x69,0x30,0x48,0x10,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x36,0x20,
0xC1,0x1F,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x20,0x42,0x10,0xFC,0x3F,
0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x42,0x10,0x44,0x04,0x00,0x00,0x00,0x00,
0x00,0x00,0x18,0x00,0xC8,0x1F,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,
0x08,0x00,0xC4,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0xE4,0x3F,0x04,0x00,
0x0C,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x27,0x25,0xF4,0x0F,0x0C,0x00,0x00,0x00,
0x00,0x00,0x18,0x00,0x24,0x25,0x24,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,
0x24,0x25,0x42,0x04,0x0C,0x00,0x00,0x00,0x00,0x00,0x30,0x20,0x24,0x25,0x82,0x03,
0x0C,0x00,0x00,0x00,0x00,0x00,0x60,0x10,0xF4,0x7F,0x61,0x0C,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x0F,0x00,0x00,0x1C,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// 湿度:     ％
0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE4,0x1F,0x00,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x20,0x28,0x10,0xFC,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x24,0x10,0x28,0x10,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x08,
0xE1,0x1F,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x04,0x22,0x10,0xFC,0x3F,
0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x02,0x22,0x10,0x44,0x04,0x00,0x00,0x00,0x00,
0x00,0x00,0x24,0x01,0xE8,0x1F,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x98,0x00,
0x88,0x04,0xC4,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x06,0x84,0x04,0x04,0x00,
0x0C,0x00,0x00,0x00,0x00,0x00,0x20,0x09,0x97,0x24,0xF4,0x0F,0x0C,0x00,0x00,0x00,
0x00,0x00,0x10,0x09,0xA4,0x14,0x24,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x09,
0xC4,0x0C,0x42,0x04,0x0C,0x00,0x00,0x00,0x00,0x00,0x04,0x09,0x84,0x04,0x82,0x03,
0x0C,0x00,0x00,0x00,0x00,0x00,0x02,0x09,0xF4,0x7F,0x61,0x0C,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x06,0x00,0x00,0x1C,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

// STR_WS wind speed & company name 384Bytes(96*32/8)

/* *****************
*   风 速: -.-m/s *
*   陕西泰新博坤  *
******************/
const uint8_t SRT_WIND[] = {
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 风速:    m/s
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/9/29 10:27:53
------------------------------------------------------------------------------*/
0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x0F,0x04,0x02,
0x00,0x00,0x00,0x00,0x00,0x00,0x2E,0x08,0x04,0x08,0xE8,0x3F,0x00,0x00,0x00,0x00,
0x00,0x00,0x5E,0x08,0x04,0x08,0x08,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x5A,0x78,
0x14,0x0A,0xC0,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0xDC,0x24,0x0A,0x40,0x12,
0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0x0C,0x44,0x09,0x4F,0x12,0x00,0x00,0x00,0x00,
0x00,0x00,0x4A,0x0A,0x44,0x09,0xC8,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0x1A,
0x84,0x08,0x08,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0x71,0x84,0x08,0x88,0x0A,
0x0C,0x00,0x00,0x00,0x00,0x00,0x4A,0xC1,0x44,0x09,0x48,0x12,0x0C,0x00,0x00,0x00,
0x00,0x00,0xCA,0x80,0x44,0x49,0x28,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0xCA,0x80,
0x24,0x52,0x08,0x02,0x0C,0x00,0x00,0x00,0x00,0x00,0x80,0xD8,0x12,0x52,0x14,0x00,
0x0C,0x00,0x00,0x00,0x00,0x00,0x40,0x78,0x02,0x60,0xE2,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 扬尘在线监控
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/11/21 10:14:23
------------------------------------------------------------------------------
0x08,0x00,0x80,0x00,0x40,0x00,0x08,0x0A,0x20,0x02,0x08,0x02,0x88,0x1F,0x80,0x00,
0x40,0x00,0x08,0x12,0x24,0x02,0x08,0x04,0x08,0x08,0x90,0x04,0x20,0x00,0x04,0x02,
0x24,0x3E,0x08,0x04,0x08,0x04,0x90,0x08,0xFF,0x7F,0x24,0x3A,0x24,0x02,0xC8,0x7F,
0x3F,0x02,0x88,0x10,0x10,0x00,0xA2,0x07,0x24,0x09,0x5F,0x40,0x08,0x01,0x84,0x20,
0x10,0x02,0x1F,0x02,0x24,0x11,0x28,0x29,0x88,0x7F,0x82,0x20,0x08,0x02,0x08,0x7A,
0xA4,0x10,0x88,0x10,0x28,0x49,0x00,0x00,0x0C,0x02,0xC4,0x07,0x20,0x00,0x58,0x20,
0x18,0x49,0x80,0x00,0xEA,0x3F,0x02,0x22,0x00,0x00,0x0C,0x00,0x0C,0x49,0x80,0x00,
0x09,0x02,0x3F,0x12,0xFC,0x1F,0x8B,0x3F,0x8B,0x48,0xFC,0x1F,0x08,0x02,0x02,0x0C,
0x24,0x12,0x08,0x04,0x88,0x44,0x80,0x00,0x08,0x02,0x00,0x44,0x24,0x12,0x08,0x04,
0x48,0x44,0x80,0x00,0x08,0x02,0x38,0x4A,0x24,0x12,0x08,0x04,0x28,0x42,0x80,0x00,
0x08,0x02,0x07,0x51,0x24,0x12,0x08,0x04,0x0A,0x29,0xFF,0x7F,0xF8,0x7F,0xC2,0x60,
0xFF,0x7F,0xEA,0x7F,0x84,0x10,0x00,0x00,0x08,0x00,0x00,0x40,0x00,0x00,0x04,0x00*/
/*  泰新博坤
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x40,0x20,0x82,0x42,
0x10,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xF0,0x1D,0xF2,0x47,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,0x00,0x04,0x82,0x40,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,
0x10,0x05,0xF2,0x47,0x92,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xA0,0x3C,0x97,0xE4,
0x92,0x00,0x00,0x00,0x00,0x00,0xC0,0xFF,0xF9,0x15,0xF2,0x47,0xFE,0x00,0x00,0x00,
0x00,0x00,0x00,0x49,0x40,0x14,0x92,0x44,0x92,0x00,0x00,0x00,0x00,0x00,0x80,0x88,
0xF0,0x15,0x92,0x44,0x92,0x00,0x00,0x00,0x00,0x00,0x40,0x5D,0x41,0x14,0x02,0x42,
0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x2A,0x50,0x15,0xF2,0xC7,0x92,0x00,0x00,0x00,
0x00,0x00,0x00,0x49,0x48,0x12,0x22,0x62,0x10,0x00,0x00,0x00,0x00,0x00,0xC0,0x8C,
0x61,0x11,0x42,0x03,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00*/

/*  荣炜科技
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x20,0x04,0x08,0x81,
0x10,0x00,0x00,0x00,0x00,0x00,0xC0,0xFF,0x21,0x04,0x27,0x81,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x22,0xA0,0x3F,0x44,0x81,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x68,0x04,0x04,0xE1,0x11,0x00,0x00,0x00,0x00,0x00,0xC0,0xFF,0x29,0x1F,0x3F,0x81,
0x10,0x00,0x00,0x00,0x00,0x00,0x40,0x08,0x29,0x04,0x44,0x81,0x7E,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,0xA8,0x3F,0x0E,0x81,0x45,0x00,0x00,0x00,0x00,0x00,0xC0,0xFF,
0x21,0x24,0x16,0xE7,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x2A,0x20,0x24,0xE5,0x81,
0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x49,0x50,0x34,0x04,0x81,0x10,0x00,0x00,0x00,
0x00,0x00,0xC0,0x88,0x91,0x04,0x04,0x81,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x08,
0x08,0x04,0x04,0xC1,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 */
    /*  渝仁蓉达
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x10,0x40,0x00,0x88,0x40,
0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x40,0x00,0xFF,0x87,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x44,0x20,0x00,0xA8,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0xBA,
0xA1,0x1F,0xFF,0x07,0xFE,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x30,0x00,0x89,0xE4,
0x10,0x00,0x00,0x00,0x00,0x00,0x80,0x1E,0x29,0x00,0x24,0x81,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x52,0x21,0x00,0x50,0x80,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x5E,
0x21,0x00,0x8C,0x81,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x53,0x21,0x00,0x03,0x86,
0x84,0x00,0x00,0x00,0x00,0x00,0x80,0x5E,0x21,0x00,0xFC,0x81,0x82,0x00,0x00,0x00,
0x00,0x00,0x40,0x12,0xE1,0x3F,0x04,0x41,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x9A,
0x21,0x00,0xFC,0x21,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00*/
 /*  中桴美达
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x20,0x38,0x04,0x41,
0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xA0,0x07,0x88,0x80,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,0x20,0x22,0xFE,0x03,0x10,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,
0xF8,0x14,0x20,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x80,0x88,0x20,0x01,0xFE,0xE3,
0x10,0x00,0x00,0x00,0x00,0x00,0x80,0x88,0xB0,0x1F,0x20,0x80,0x10,0x00,0x00,0x00,
0x00,0x00,0x80,0x88,0x70,0x08,0xFF,0x87,0x28,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,
0x28,0x04,0x20,0x80,0x48,0x00,0x00,0x00,0x00,0x00,0x80,0x88,0xA0,0x3F,0xFF,0x87,
0x84,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x20,0x04,0x50,0x80,0x82,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,0x20,0x04,0x8C,0x41,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x08,
0x20,0x06,0x03,0x26,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00*/

};

const uint8_t SRT_WN[] = {  // windspeed & noise
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 风速:    m/s
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/9/29 10:27:53
------------------------------------------------------------------------------*/
0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x0F,0x04,0x02,
0x00,0x00,0x00,0x00,0x00,0x00,0x2E,0x08,0x04,0x08,0xE8,0x3F,0x00,0x00,0x00,0x00,
0x00,0x00,0x5E,0x08,0x04,0x08,0x08,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x5A,0x78,
0x14,0x0A,0xC0,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0xDC,0x24,0x0A,0x40,0x12,
0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0x0C,0x44,0x09,0x4F,0x12,0x00,0x00,0x00,0x00,
0x00,0x00,0x4A,0x0A,0x44,0x09,0xC8,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0x1A,
0x84,0x08,0x08,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0x71,0x84,0x08,0x88,0x0A,
0x0C,0x00,0x00,0x00,0x00,0x00,0x4A,0xC1,0x44,0x09,0x48,0x12,0x0C,0x00,0x00,0x00,
0x00,0x00,0xCA,0x80,0x44,0x49,0x28,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0xCA,0x80,
0x24,0x52,0x08,0x02,0x0C,0x00,0x00,0x00,0x00,0x00,0x80,0xD8,0x12,0x52,0x14,0x00,
0x0C,0x00,0x00,0x00,0x00,0x00,0x40,0x78,0x02,0x60,0xE2,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// 噪声:     dB
0xC0,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x10,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4F,0x10,0xFF,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xC9,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x1F,
0x09,0x00,0xFE,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x22,0xE9,0x3D,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x22,0x29,0x25,0xFC,0x1F,0x00,0x00,0x00,0x00,
0x00,0x00,0x40,0x22,0x29,0x25,0x84,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x1E,
0xE9,0x3D,0x84,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x22,0x09,0x02,0xFC,0x1F,
0x0C,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0xFF,0x7F,0x04,0x00,0x0C,0x00,0x00,0x00,
0x00,0x00,0x42,0x42,0x89,0x06,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,
0x40,0x0A,0x04,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x64,0x22,0x20,0x12,0x02,0x00,
0x0C,0x00,0x00,0x00,0x00,0x00,0xD8,0x1F,0x18,0x62,0x02,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
const uint8_t SRT_FLAG[] = {
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 扬尘在线监控
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/11/21 10:14:23
------------------------------------------------------------------------------*/
0x08,0x00,0x80,0x00,0x40,0x00,0x08,0x0A,0x20,0x02,0x08,0x02,0x88,0x1F,0x80,0x00,
0x40,0x00,0x08,0x12,0x24,0x02,0x08,0x04,0x08,0x08,0x90,0x04,0x20,0x00,0x04,0x02,
0x24,0x3E,0x08,0x04,0x08,0x04,0x90,0x08,0xFF,0x7F,0x24,0x3A,0x24,0x02,0xC8,0x7F,
0x3F,0x02,0x88,0x10,0x10,0x00,0xA2,0x07,0x24,0x09,0x5F,0x40,0x08,0x01,0x84,0x20,
0x10,0x02,0x1F,0x02,0x24,0x11,0x28,0x29,0x88,0x7F,0x82,0x20,0x08,0x02,0x08,0x7A,
0xA4,0x10,0x88,0x10,0x28,0x49,0x00,0x00,0x0C,0x02,0xC4,0x07,0x20,0x00,0x58,0x20,
0x18,0x49,0x80,0x00,0xEA,0x3F,0x02,0x22,0x00,0x00,0x0C,0x00,0x0C,0x49,0x80,0x00,
0x09,0x02,0x3F,0x12,0xFC,0x1F,0x8B,0x3F,0x8B,0x48,0xFC,0x1F,0x08,0x02,0x02,0x0C,
0x24,0x12,0x08,0x04,0x88,0x44,0x80,0x00,0x08,0x02,0x00,0x44,0x24,0x12,0x08,0x04,
0x48,0x44,0x80,0x00,0x08,0x02,0x38,0x4A,0x24,0x12,0x08,0x04,0x28,0x42,0x80,0x00,
0x08,0x02,0x07,0x51,0x24,0x12,0x08,0x04,0x0A,0x29,0xFF,0x7F,0xF8,0x7F,0xC2,0x60,
0xFF,0x7F,0xEA,0x7F,0x84,0x10,0x00,0x00,0x08,0x00,0x00,0x40,0x00,0x00,0x04,0x00,

/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 风向:
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2017/5/12 16:47:21
------------------------------------------------------------------------------*/
// 风向:
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x0F,0x40,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x08,0x20,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x0A,0xFC,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x14,0x0A,0x04,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x09,0x04,0x20,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x09,0xE4,0x27,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x84,0x08,0x24,0x24,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x84,0x08,0x24,0x24,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x09,0x24,0x24,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x09,0xE4,0x27,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x24,0x2A,0x04,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x14,0x2A,0x04,0x20,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x30,0x04,0x20,
0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x20,0x04,0x38,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 专业治污除霾
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/12/21 15:08:01
------------------------------------------------------------------------------
0x80,0x00,0x20,0x02,0x00,0x02,0x00,0x00,0x00,0x02,0xFC,0x1F,0x80,0x00,0x20,0x02,
0x04,0x02,0xC4,0x1F,0x1E,0x02,0x80,0x00,0x80,0x00,0x20,0x02,0x08,0x01,0x08,0x00,
0x12,0x05,0xFE,0x7F,0xFC,0x1F,0x20,0x02,0x88,0x08,0x08,0x00,0x8A,0x08,0x82,0x40,
0x40,0x00,0x22,0x22,0x41,0x10,0x01,0x00,0x4A,0x10,0xB9,0x2E,0x40,0x00,0x24,0x22,
0xE2,0x3F,0xE2,0x7F,0xA6,0x6F,0x0C,0x00,0xFF,0x7F,0x24,0x12,0x02,0x20,0x02,0x01,
0x0A,0x02,0xD3,0x3F,0x20,0x00,0x28,0x12,0x08,0x00,0x08,0x01,0x12,0x02,0xB4,0x24,
0x10,0x00,0x28,0x0A,0xC8,0x1F,0x88,0x00,0xF2,0x3F,0x8C,0x3F,0xF0,0x0F,0x28,0x06,
0x44,0x10,0x84,0x1F,0x12,0x02,0x93,0x24,0x00,0x08,0x20,0x02,0x47,0x10,0x07,0x10,
0x56,0x0A,0xA8,0x3F,0x00,0x04,0x20,0x02,0x44,0x10,0x04,0x10,0x4A,0x12,0x26,0x04,
0x60,0x02,0x20,0x02,0x44,0x10,0x04,0x10,0x22,0x22,0xB0,0x3F,0x80,0x01,0x20,0x02,
0x44,0x10,0x04,0x10,0x12,0x22,0x2C,0x04,0x00,0x02,0xFF,0x7F,0xC4,0x1F,0x04,0x0A,
0x82,0x02,0xA3,0x7F,0x00,0x04,0x00,0x00,0x40,0x10,0x00,0x04,0x02,0x01,0x18,0x00*/
};

const uint8_t SRT_PMW[] = { // PM2.5 & PM10 & windspeed
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 扬尘在线监控
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/11/21 10:14:23
------------------------------------------------------------------------------*/
0x08,0x00,0x80,0x00,0x40,0x00,0x08,0x0A,0x20,0x02,0x08,0x02,0x88,0x1F,0x80,0x00,
0x40,0x00,0x08,0x12,0x24,0x02,0x08,0x04,0x08,0x08,0x90,0x04,0x20,0x00,0x04,0x02,
0x24,0x3E,0x08,0x04,0x08,0x04,0x90,0x08,0xFF,0x7F,0x24,0x3A,0x24,0x02,0xC8,0x7F,
0x3F,0x02,0x88,0x10,0x10,0x00,0xA2,0x07,0x24,0x09,0x5F,0x40,0x08,0x01,0x84,0x20,
0x10,0x02,0x1F,0x02,0x24,0x11,0x28,0x29,0x88,0x7F,0x82,0x20,0x08,0x02,0x08,0x7A,
0xA4,0x10,0x88,0x10,0x28,0x49,0x00,0x00,0x0C,0x02,0xC4,0x07,0x20,0x00,0x58,0x20,
0x18,0x49,0x80,0x00,0xEA,0x3F,0x02,0x22,0x00,0x00,0x0C,0x00,0x0C,0x49,0x80,0x00,
0x09,0x02,0x3F,0x12,0xFC,0x1F,0x8B,0x3F,0x8B,0x48,0xFC,0x1F,0x08,0x02,0x02,0x0C,
0x24,0x12,0x08,0x04,0x88,0x44,0x80,0x00,0x08,0x02,0x00,0x44,0x24,0x12,0x08,0x04,
0x48,0x44,0x80,0x00,0x08,0x02,0x38,0x4A,0x24,0x12,0x08,0x04,0x28,0x42,0x80,0x00,
0x08,0x02,0x07,0x51,0x24,0x12,0x08,0x04,0x0A,0x29,0xFF,0x7F,0xF8,0x7F,0xC2,0x60,
0xFF,0x7F,0xEA,0x7F,0x84,0x10,0x00,0x00,0x08,0x00,0x00,0x40,0x00,0x00,0x04,0x00,
/* *****************
*   PM2.5:    ug  *
******************/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x77,0x3C,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x42,0x36,0x42,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x36,0x42,0x00,
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x36,0x42,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x42,0x36,0x20,0x00,0x1A,0x00,0x00,0x00,0x00,0x00,0x63,0x7C,
0x3E,0x2A,0x20,0x00,0x26,0x00,0x00,0x00,0x00,0x00,0x42,0x22,0x02,0x2A,0x10,0x00,
0x40,0x0C,0x00,0x00,0x00,0x00,0x42,0x22,0x02,0x2A,0x08,0x00,0x40,0x0C,0x00,0x00,
0x00,0x00,0x42,0x1C,0x02,0x2A,0x04,0x00,0x42,0x00,0x00,0x00,0x00,0x00,0x42,0x02,
0x02,0x2A,0x42,0x06,0x22,0x0C,0x00,0x00,0x00,0x00,0x62,0x3C,0x07,0x6B,0x7E,0x06,
0x1C,0x0C,0x00,0x00,0x00,0x00,0xDC,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,
/* *****************
*   PM1 0:    ug  *
******************/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x77,0x08,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x42,0x36,0x0E,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x36,0x08,0x42,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x36,0x08,0x42,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x42,0x36,0x08,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x7C,
0x3E,0x2A,0x08,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x22,0x02,0x2A,0x08,0x42,
0x0C,0x00,0x00,0x00,0x00,0x00,0x42,0x22,0x02,0x2A,0x08,0x42,0x0C,0x00,0x00,0x00,
0x00,0x00,0x42,0x1C,0x02,0x2A,0x08,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x02,
0x02,0x2A,0x08,0x24,0x0C,0x00,0x00,0x00,0x00,0x00,0x62,0x3C,0x07,0x6B,0x3E,0x18,
0x0C,0x00,0x00,0x00,0x00,0x00,0xDC,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,

/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 风速:    m/s
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/9/29 10:27:53
------------------------------------------------------------------------------*/
0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x0F,0x04,0x02,
0x00,0x00,0x00,0x00,0x00,0x00,0x2E,0x08,0x04,0x08,0xE8,0x3F,0x00,0x00,0x00,0x00,
0x00,0x00,0x5E,0x08,0x04,0x08,0x08,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x5A,0x78,
0x14,0x0A,0xC0,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0xDC,0x24,0x0A,0x40,0x12,
0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0x0C,0x44,0x09,0x4F,0x12,0x00,0x00,0x00,0x00,
0x00,0x00,0x4A,0x0A,0x44,0x09,0xC8,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0x1A,
0x84,0x08,0x08,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0x71,0x84,0x08,0x88,0x0A,
0x0C,0x00,0x00,0x00,0x00,0x00,0x4A,0xC1,0x44,0x09,0x48,0x12,0x0C,0x00,0x00,0x00,
0x00,0x00,0xCA,0x80,0x44,0x49,0x28,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0xCA,0x80,
0x24,0x52,0x08,0x02,0x0C,0x00,0x00,0x00,0x00,0x00,0x80,0xD8,0x12,0x52,0x14,0x00,
0x0C,0x00,0x00,0x00,0x00,0x00,0x40,0x78,0x02,0x60,0xE2,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

const uint8_t SRT_THN[] = { // Temperature & Humidity & Noise
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 扬尘在线监控
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/11/21 10:14:23
------------------------------------------------------------------------------
0x08,0x00,0x80,0x00,0x40,0x00,0x08,0x0A,0x20,0x02,0x08,0x02,0x88,0x1F,0x80,0x00,
0x40,0x00,0x08,0x12,0x24,0x02,0x08,0x04,0x08,0x08,0x90,0x04,0x20,0x00,0x04,0x02,
0x24,0x3E,0x08,0x04,0x08,0x04,0x90,0x08,0xFF,0x7F,0x24,0x3A,0x24,0x02,0xC8,0x7F,
0x3F,0x02,0x88,0x10,0x10,0x00,0xA2,0x07,0x24,0x09,0x5F,0x40,0x08,0x01,0x84,0x20,
0x10,0x02,0x1F,0x02,0x24,0x11,0x28,0x29,0x88,0x7F,0x82,0x20,0x08,0x02,0x08,0x7A,
0xA4,0x10,0x88,0x10,0x28,0x49,0x00,0x00,0x0C,0x02,0xC4,0x07,0x20,0x00,0x58,0x20,
0x18,0x49,0x80,0x00,0xEA,0x3F,0x02,0x22,0x00,0x00,0x0C,0x00,0x0C,0x49,0x80,0x00,
0x09,0x02,0x3F,0x12,0xFC,0x1F,0x8B,0x3F,0x8B,0x48,0xFC,0x1F,0x08,0x02,0x02,0x0C,
0x24,0x12,0x08,0x04,0x88,0x44,0x80,0x00,0x08,0x02,0x00,0x44,0x24,0x12,0x08,0x04,
0x48,0x44,0x80,0x00,0x08,0x02,0x38,0x4A,0x24,0x12,0x08,0x04,0x28,0x42,0x80,0x00,
0x08,0x02,0x07,0x51,0x24,0x12,0x08,0x04,0x0A,0x29,0xFF,0x7F,0xF8,0x7F,0xC2,0x60,
0xFF,0x7F,0xEA,0x7F,0x84,0x10,0x00,0x00,0x08,0x00,0x00,0x40,0x00,0x00,0x04,0x00,*/
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 风向:
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2017/5/12 16:47:21
------------------------------------------------------------------------------*/
// 风向:
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x0F,0x40,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x08,0x20,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x0A,0xFC,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x14,0x0A,0x04,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x09,0x04,0x20,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x09,0xE4,0x27,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x84,0x08,0x24,0x24,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x84,0x08,0x24,0x24,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x09,0x24,0x24,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x09,0xE4,0x27,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x24,0x2A,0x04,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x14,0x2A,0x04,0x20,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x30,0x04,0x20,
0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x20,0x04,0x38,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// 温度:     ℃
0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0xC4,0x1F,0x00,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x89,0x2F,0x48,0x10,0xFC,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x69,0x30,0x48,0x10,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x36,0x20,
0xC1,0x1F,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x20,0x42,0x10,0xFC,0x3F,
0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x42,0x10,0x44,0x04,0x00,0x00,0x00,0x00,
0x00,0x00,0x18,0x00,0xC8,0x1F,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,
0x08,0x00,0xC4,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0xE4,0x3F,0x04,0x00,
0x0C,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x27,0x25,0xF4,0x0F,0x0C,0x00,0x00,0x00,
0x00,0x00,0x18,0x00,0x24,0x25,0x24,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,
0x24,0x25,0x42,0x04,0x0C,0x00,0x00,0x00,0x00,0x00,0x30,0x20,0x24,0x25,0x82,0x03,
0x0C,0x00,0x00,0x00,0x00,0x00,0x60,0x10,0xF4,0x7F,0x61,0x0C,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x0F,0x00,0x00,0x1C,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// 湿度:     ％
0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE4,0x1F,0x00,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x20,0x28,0x10,0xFC,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x24,0x10,0x28,0x10,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x08,
0xE1,0x1F,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x04,0x22,0x10,0xFC,0x3F,
0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x02,0x22,0x10,0x44,0x04,0x00,0x00,0x00,0x00,
0x00,0x00,0x24,0x01,0xE8,0x1F,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x98,0x00,
0x88,0x04,0xC4,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x06,0x84,0x04,0x04,0x00,
0x0C,0x00,0x00,0x00,0x00,0x00,0x20,0x09,0x97,0x24,0xF4,0x0F,0x0C,0x00,0x00,0x00,
0x00,0x00,0x10,0x09,0xA4,0x14,0x24,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x09,
0xC4,0x0C,0x42,0x04,0x0C,0x00,0x00,0x00,0x00,0x00,0x04,0x09,0x84,0x04,0x82,0x03,
0x0C,0x00,0x00,0x00,0x00,0x00,0x02,0x09,0xF4,0x7F,0x61,0x0C,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x06,0x00,0x00,0x1C,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// 噪声:     dB
0xC0,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x10,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4F,0x10,0xFF,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xC9,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x1F,
0x09,0x00,0xFE,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x22,0xE9,0x3D,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x22,0x29,0x25,0xFC,0x1F,0x00,0x00,0x00,0x00,
0x00,0x00,0x40,0x22,0x29,0x25,0x84,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x1E,
0xE9,0x3D,0x84,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x22,0x09,0x02,0xFC,0x1F,
0x0C,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0xFF,0x7F,0x04,0x00,0x0C,0x00,0x00,0x00,
0x00,0x00,0x42,0x42,0x89,0x06,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,
0x40,0x0A,0x04,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x64,0x22,0x20,0x12,0x02,0x00,
0x0C,0x00,0x00,0x00,0x00,0x00,0xD8,0x1F,0x18,0x62,0x02,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/* *********************  local variable & macro  ****************************/

uint16_t get_chksum16(uint8_t *data,uint16_t num)
{
    uint16_t i,sum = 0;

    for (i=0;i<num;i++)
    {
        sum += data[i];
    }

    return sum&0xffff;
}

/*  get TLV "length" field length */
uint8_t get_TLV_length(uint16_t tlv_len)
{
    if (tlv_len < 0x80)   // 1Byte
    {
        return 1;
    }
    else if (tlv_len < 0xff && tlv_len >= 0x80)// 2Byte
    {
        return 2;
    }
    else    // 3Byte
    {
        return 3;
    }
}

void pop(uint8_t a[] , int num)  
{  
    int i = 0;  
    while (1)  
    {  
        a[i] = num % 10;  
        num = num / 10;  
        i++;  
        if (num == 0) break;  
    }  
}  

/* **************************************************
 fucntion:      APP_led_reciveisr
 input:     byte: data received form uart6
 output:
 describe:  uart receive isr of LED
***************************************************/
void APP_led_rcvisr(void)
{
     enum
    {
        LED_RCVSTEP_IDLE = 0,
        LED_RCVSTEP_SYN1,   // 0xAA
        LED_RCVSTEP_SYN2,   // 0x55
        LED_RCVSTEP_ADDR1,  // 0xFF
        LED_RCVSTEP_ADDR2,  // 0xFF
        LED_RCVSTEP_LEN1,   // low byte
        LED_RCVSTEP_LEN2,   // high byte
        LED_RCVSTEP_DAT,

        LED_RCVSTEP_MAX
     };
    static uint8_t led_rcvstep = LED_RCVSTEP_IDLE;
    static uint8_t frame_len = 0;

    uint32_t tick;
    //uint32_t index;
    uint8_t byte = led_rcvbyte;
    static uint16_t chksum;

    HAL_UART_Receive_IT(HDL_UART_LED, &led_rcvbyte, 1);

    tick = HAL_GetTick();
    if ((tick - led_rcvbuf.timestamp) > 200)
    {
        led_rcvstep = LED_RCVSTEP_IDLE;
        led_rcvbuf.rcvindex = 0;
    }
    led_rcvbuf.timestamp = tick;

    switch (led_rcvstep)
    {
        case LED_RCVSTEP_IDLE:
            led_rcvbuf.rcvindex = 0;
            if (byte == (EX30_SYN & 0xFF))
            {       // find start byte(low)
                led_rcvstep = LED_RCVSTEP_SYN1;
                led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
            }
            break;
        case LED_RCVSTEP_SYN1:
            if (byte == ((EX30_SYN >> 8) & 0xFF))
            {       // find start byte(high)
                led_rcvstep = LED_RCVSTEP_SYN2;
                led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
            }
        break;
        case LED_RCVSTEP_SYN2:
           if (byte == (EX30_ADDR & 0x00FF) ||      //EX30-TLV V1.0.1
               byte == (EX30_ADDR_1_0_4 & 0x00FF))  //EX30-TLV V1.0.4
           {        // find address byte(low)
               led_rcvstep = LED_RCVSTEP_ADDR1;
               led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
           }
        break;
        case LED_RCVSTEP_ADDR1:
            if (byte == (EX30_ADDR >> 8 & 0xFF) ||      //EX30-TLV V1.0.1
                byte == (EX30_ADDR_1_0_4 >> 8 & 0xFF))  //EX30-TLV V1.0.4
           {        // find address byte(high)
               led_rcvstep = LED_RCVSTEP_ADDR2;
               led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
           }
        break;
        case LED_RCVSTEP_ADDR2:
            led_rcvbuf.len = byte;
            led_rcvstep = LED_RCVSTEP_LEN1;
            led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
        break;
        case LED_RCVSTEP_LEN1:
            led_rcvbuf.len += byte<<8;
            frame_len = led_rcvbuf.len;
            led_rcvstep = LED_RCVSTEP_LEN2;
            led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
        break;
        case LED_RCVSTEP_LEN2:
            if (led_rcvbuf.rcvindex >= LED_RCVBUFSIZE)
            {
                led_rcvstep = LED_RCVSTEP_IDLE;
                led_rcvbuf.rcvindex = 0;
            }
            else    // 接收dat信息(serial+type+cmd+tlv)
            {
                led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
                if (led_rcvbuf.rcvindex == frame_len + 6)   // full frame is received
                {
                    led_rcvbuf.serial = led_rcvbuf.rcvbyte[6] + (led_rcvbuf.rcvbyte[7]<<8);
                    led_rcvbuf.type = led_rcvbuf.rcvbyte[8];
                    led_rcvbuf.cmd = led_rcvbuf.rcvbyte[9];
                    led_rcvbuf.tlv[0] = led_rcvbuf.rcvbyte[10]; // 写应答，返回错误码;
                                                                // 读应答，返回tag/设备信息（0x18）
                    if (led_rcvbuf.cmd == EX30_ACK_RD)
                    {
                        led_rcvbuf.tlv[1] = led_rcvbuf.rcvbyte[11];     // 保存设备信息长度
                        for (uint8_t i = 0; i < led_rcvbuf.rcvbyte[11]; i++)    // 保存设备信息
                        {
                            led_rcvbuf.tlv[2 + i] = led_rcvbuf.rcvbyte[12 + i];
                        }
                    }

                    led_rcvbuf.chksum = led_rcvbuf.rcvbyte[(led_rcvbuf.rcvindex - 2)] + ((led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex - 1]) << 8);
                    chksum = get_chksum16(led_rcvbuf.rcvbyte, frame_len + 4);
                    frame_len = 0;
                    if (chksum == led_rcvbuf.chksum)
                    {
                        led_rcvbuf.valid = TRUE;
                        led_sendbuf.busy = FALSE;
                    }
                    led_rcvstep = LED_RCVSTEP_IDLE;
                    led_rcvbuf.rcvindex = 0;
                }
            }
        break;

        default :
            led_rcvstep = LED_RCVSTEP_IDLE;
            led_rcvbuf.rcvindex = 0;
            break;

    }
}

/* **************************************************
 fucntion:      APP_led_full
 input:
 output:
 describe:  send full frame
***************************************************/
void APP_led_full(APP_EX30_TypeDef *tlv)
{
    uint8_t* buf = led_sendbuf.dat;
    uint16_t chksum;
    //uint32_t length;

    // ------------ start of update ---------------

    FILL_HEAD(&buf);
    FILL_LEN(&buf, tlv->len);   // connect frame length
    FILL_SERIAL(&buf, tlv->serial); // serial number
    FILL_TYPE(&buf, tlv->type);
    FILL_CMD(&buf, tlv->cmd);
    for (uint8_t i = 0; i < tlv->tlvnum;i++)
    {
        // tag
        FILL_1B(&buf, tlv->tlv_buf[i].tag);

        // tag length
        if (tlv->tlv_buf[i].len < 0x80)   // 1Byte
        {
            FILL_1B(&buf, tlv->tlv_buf[i].len & 0xff);
        }
        else if (tlv->tlv_buf[i].len < 0xff && tlv->tlv_buf[i].len >= 0x80)// 2Byte
        {
            FILL_1B(&buf, 0x81);
            FILL_1B(&buf, tlv->tlv_buf[i].len & 0xFF);
        }
        else    // 3Byte
        {
            FILL_1B(&buf, 0x82);
            FILL_2B(&buf, tlv->tlv_buf[i].len);
        }
        // tag value
        for (uint16_t j = 0; j < tlv->tlv_buf[i].len; j++)
        {
            FILL_1B(&buf, tlv->tlv_buf[i].value[j]);
        }
    }
    chksum = get_chksum16(led_sendbuf.dat, (buf - led_sendbuf.dat));
    FILL_CHKSUM(&buf, chksum);


    // set ready flag to send.
    led_sendbuf.length = buf - led_sendbuf.dat;
    led_sendbuf.valid = TRUE;
    led_sendbuf.busy = TRUE;

    HAL_UART_Transmit_IT(HDL_UART_LED, led_sendbuf.dat, led_sendbuf.length);
}

/* **************************************************
 fucntion:      APP_led_display
 input:
 output:
 describe:  output routine of LED
***************************************************/

void APP_led_display(void)
{
    //uint8_t str[20];

    //  update pm2.5&pm10 txt
    APP_led_uptxt();
    //  update temperature & humidity txt
    APP_led_thtxt();
    //  update wind speed txt
    APP_led_wltxt();
}


/* **************************************************
 fucntion:      APP_led_ini
 input:
 output:
 describe:  LED initial
***************************************************/

void APP_led_ini(void)
{
    HAL_UART_Receive_IT(HDL_UART_LED, &led_rcvbyte, 1);

    led_stat.update = TRUE;
    led_stat.packnum = 0;
    led_sendbuf.valid = FALSE;
    led_sendbuf.busy = FALSE;

/* 
    //APP_led_scrlogo();
    // communication handle
    APP_led_connect();
    HAL_Delay(1000);

    // display pm2.5&pm10 subtitle screen
    APP_led_updel();
    HAL_Delay(1000);
    APP_led_upopt();
    HAL_Delay(1000);
    APP_led_upsrt();
    HAL_Delay(1000);
    APP_led_uptxt();
    HAL_Delay(1000);

    // display temperature&humidity subtitle screen
    APP_led_thdel();
    HAL_Delay(1000);
    APP_led_thopt();
    HAL_Delay(1000);
    APP_led_thsrt();
    HAL_Delay(1000);
    APP_led_thtxt();
    HAL_Delay(1000);

    // display windspeed & company name subtitle screen
    APP_led_wldel();
    HAL_Delay(1000);
    APP_led_wlopt();
    HAL_Delay(1000);
    APP_led_wlsrt();
    HAL_Delay(1000);
    APP_led_wltxt();
    HAL_Delay(1000);
*/
}


/* **************************************************
 fucntion:      APP_led_logo
 input:
 output:
 describe:  show logo screen
***************************************************/

void APP_led_logo(void)
{
    uint8_t* buf = led_sendbuf.dat;

    // set ready flag to send.
    led_sendbuf.length = buf - led_sendbuf.dat;
    led_sendbuf.valid = TRUE;

    HAL_UART_Transmit(HDL_UART_LED, led_sendbuf.dat, led_sendbuf.length, 50);
    led_sendbuf.valid = FALSE;
}


/* **************************************************
 fucntion:      APP_led_connect
 input:
 output:
 describe:  connect ex-30 control card
***************************************************/

void APP_led_connect(void)
{
    APP_EX30_TypeDef ptlv;
    //uint8_t* buf = led_sendbuf.dat;
    //uint32_t length;

    // ------------ start of update ---------------
    ptlv.len = 0;

    ptlv.serial = led_stat.packnum++;
    ptlv.len += 2;

    ptlv.type = EX30_TYPE;
    ptlv.len++;

    ptlv.cmd = EX30_CMD_RD;
    ptlv.len++;

    ptlv.tlvnum = 1;

    ptlv.tlv_buf[0].tag = EX30_TAG_DEVINFO;
    ptlv.len++;

    ptlv.tlv_buf[0].len = 0x0001;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[0].len);

    ptlv.tlv_buf[0].value[0] = 0x00;    // default
    ptlv.len++;

    ptlv.len += 2;  // check sum

    APP_led_full(&ptlv);
}

/* **************************************************
 fucntion:      APP_led_setRTC
 input:
 output:
 describe:  set led screen real time clock parameters
***************************************************/
void APP_led_setsrcrtc(void)
{
    APP_EX30_TypeDef ptlv;
    RTC_TimeTypeDef sTime;
    RTC_DateTypeDef sDate;

    // 获取RTC时钟
    HAL_RTC_GetTime(&hrtc, &sTime, FORMAT_BIN);
    HAL_RTC_GetDate(&hrtc, &sDate, FORMAT_BIN);
    //uint8_t* buf = led_sendbuf.dat;
    //uint32_t length;

    // ------------ start of update ---------------
    ptlv.len = 0;
    ptlv.serial = led_stat.packnum++;
    ptlv.len += 2;

    ptlv.type = EX30_TYPE;
    ptlv.len++;

    ptlv.cmd = EX30_CMD_WR;
    ptlv.len++;

    ptlv.tlvnum = 1;

    ptlv.tlv_buf[0].tag = EX30_TAG_RTC;
    ptlv.len++;

    ptlv.tlv_buf[0].len = 0x0007;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[0].len);

    ptlv.tlv_buf[0].value[0] = (2000 + sDate.Year)&0xff;
    ptlv.tlv_buf[0].value[1] = ((2000 + sDate.Year) >> 8) & 0xff;
    ptlv.tlv_buf[0].value[2] = sDate.Month;
    ptlv.tlv_buf[0].value[3] = sDate.Date;
    ptlv.tlv_buf[0].value[4] = sTime.Hours;
    ptlv.tlv_buf[0].value[5] = sTime.Minutes;
    ptlv.tlv_buf[0].value[6] = sTime.Seconds;

    ptlv.len += ptlv.tlv_buf[0].len;

    ptlv.len += 2;  // check sum

    APP_led_full(&ptlv);
}

/* **************************************************
 fucntion:      APP_led_setsrccfg
 input:         uint8_t length:LED pixel length
                uint8_t width :LED pixel width
 output:
 describe:  set led screen parameters
***************************************************/
void APP_led_setsrccfg(void)
{
    APP_EX30_TypeDef ptlv;
    //uint8_t* buf = led_sendbuf.dat;
    //uint32_t length;

    // ------------ start of update ---------------
    ptlv.len = 0;
    ptlv.serial = led_stat.packnum++;
    ptlv.len += 2;

    ptlv.type = EX30_TYPE;
    ptlv.len++;

    ptlv.cmd = EX30_CMD_WR;
    ptlv.len++;

    ptlv.tlvnum = 1;

    ptlv.tlv_buf[0].tag = EX30_TAG_SCRPRAM;
    ptlv.len++;

    ptlv.tlv_buf[0].len = 0x0008;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[0].len);

    ptlv.tlv_buf[0].value[0] = LED_LENGTH & 0xff;  // 64
    ptlv.tlv_buf[0].value[1] = (LED_LENGTH >> 8) & 0xff;  
    ptlv.tlv_buf[0].value[2] = LED_WIDTH & 0xff;  // 16
    ptlv.tlv_buf[0].value[3] = (LED_WIDTH >> 8) & 0xff;  // (16 >> 8)&0xff
    ptlv.tlv_buf[0].value[4] = 0x02;    // 双基色
    ptlv.tlv_buf[0].value[5] = 0x01;    // 数据极性高
    ptlv.tlv_buf[0].value[6] = 0x01;    // OE极性高
    ptlv.tlv_buf[0].value[7] = 0x00;    // 1/16扫描方式

    ptlv.len += ptlv.tlv_buf[0].len;

    ptlv.len += 2;  // check sum

    APP_led_full(&ptlv);
}


/* **************************************************
 fucntion:      APP_led_setlight
 input:
 output:
 describe:  set led screen parameters
***************************************************/
void APP_led_setlight(void)
{
    APP_EX30_TypeDef ptlv;
    //uint8_t* buf = led_sendbuf.dat;
    //uint32_t length;

    // ------------ start of update ---------------
    ptlv.len = 0;
    ptlv.serial = led_stat.packnum++;
    ptlv.len += 2;

    ptlv.type = EX30_TYPE;
    ptlv.len++;

    ptlv.cmd = EX30_CMD_WR;
    ptlv.len++;

    ptlv.tlvnum = 1;

    ptlv.tlv_buf[0].tag = EX30_TAG_LIGHT;
    ptlv.len++;

    ptlv.tlv_buf[0].len = 0x02;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[0].len);

    ptlv.tlv_buf[0].value[0] = 0x00;    //
    ptlv.tlv_buf[0].value[1] = 0x01;    // 1
    ptlv.len += ptlv.tlv_buf[0].len;

    ptlv.len += 2;  // check sum
    APP_led_full(&ptlv);
}

/* **************************************************
 fucntion:      APP_led_del
 input:
 output:
 describe:  send delete program frame
***************************************************/

void APP_led_del(uint8_t del_type, uint8_t prgm_id, uint8_t part_id, uint8_t item_id)
{
    APP_EX30_TypeDef ptlv;
    //uint8_t* buf = led_sendbuf.dat;
    //uint32_t length;

    // ------------ start of update ---------------
    ptlv.len = 0;

    ptlv.serial = led_stat.packnum++;
    ptlv.len += 2;

    ptlv.type = EX30_TYPE;
    ptlv.len++;

    ptlv.cmd = EX30_CMD_WR;
    ptlv.len++;

    ptlv.tlvnum = 1;

    ptlv.tlv_buf[0].tag = EX30_TAG_DEL;
    ptlv.len++;

    switch (del_type)
    {
    case TAG_DEL_PRGM:
        ptlv.tlv_buf[0].len = 0x0002;

        ptlv.tlv_buf[0].value[0] = TAG_DEL_PRGM;    // delete program
        ptlv.tlv_buf[0].value[1] = prgm_id; // program ID
        break;
    case TAG_DEL_PART:
        ptlv.tlv_buf[0].len = 0x03;

        ptlv.tlv_buf[0].value[0] = TAG_DEL_PART;    // delete program
        ptlv.tlv_buf[0].value[1] = prgm_id; // program ID
        ptlv.tlv_buf[0].value[2] = part_id; // part ID
        break;
    case TAG_DEL_ITEM:
        ptlv.tlv_buf[0].len = 0x04;

        ptlv.tlv_buf[0].value[0] = TAG_DEL_ITEM;    // delete program
        ptlv.tlv_buf[0].value[1] = prgm_id; // program ID
        ptlv.tlv_buf[0].value[2] = part_id; // part ID
        ptlv.tlv_buf[0].value[3] = item_id; // playitem ID
        break;
    default:
        break;
    }
    ptlv.len += get_TLV_length(ptlv.tlv_buf[0].len);
    ptlv.len += ptlv.tlv_buf[0].len;

    ptlv.len += 2;//checksum size
    APP_led_full(&ptlv);
}

void APP_led_prgmdel(void)
{
    APP_led_del(TAG_DEL_PRGM, PRGM_ALL, PART_ALL, PART_ALL);
}
/* **************************************************
 fucntion:      APP_led_updel
 input:
 output:
 describe:  send delete pm2.5&pm10 program frame
***************************************************/
void APP_led_updel(void)
{
    APP_led_del(TAG_DEL_PRGM, PRGRM_PM, 0, 0);
}
void APP_led_uptxtdel(void)
{
    APP_led_del(TAG_DEL_ITEM, PRGRM_PM, 1, 0);
}

/* **************************************************
 fucntion:      APP_led_htdel
 input:
 output:
 describe:  send delete humidity&temperature program frame
***************************************************/
void APP_led_thdel(void)
{
    APP_led_del(TAG_DEL_PRGM, PRGRM_TH, 0, 0);
}
void APP_led_thtxtdel(void)
{
    APP_led_del(TAG_DEL_ITEM, PRGRM_TH, 1, 0);
}

/* **************************************************
 fucntion:      APP_led_wldel
 input:
 output:
 describe:  send delete wind speed&company logo program frame
***************************************************/

void APP_led_wldel(void)
{
    APP_led_del(TAG_DEL_PRGM, PRGRM_WL, 0, 0);
}
void APP_led_wltxtdel(void)
{
    APP_led_del(TAG_DEL_ITEM, PRGRM_WL, 1, 0);
}

/* **************************************************
 fucntion:      APP_led_wndel
 input:
 output:
 describe:  send delete wind speed&noise program frame
***************************************************/

void APP_led_wndel(void)
{
    APP_led_del(TAG_DEL_PRGM, PRGRM_WN, 0, 0);
}
void APP_led_wntxtdel(void)
{
    APP_led_del(TAG_DEL_ITEM, PRGRM_WN, 1, 0);
}

/* **************************************************
 fucntion:      APP_led_flagdel
 input:
 output:
 describe:  send delete flag program frame
***************************************************/

void APP_led_flagdel(void)
{
    APP_led_del(TAG_DEL_PRGM, PRGRM_FLAG, 0, 0);
}
void APP_led_flagtxtdel(void)
{
    APP_led_del(TAG_DEL_ITEM, PRGRM_FLAG, 1, 0);
}

/* **************************************************
 fucntion:      APP_led_flagdel
 input:
 output:
 describe:  send delete flag program frame
***************************************************/

void APP_led_vanetxtdel(void)
{
    APP_led_flagtxtdel();
}

/* **************************************************
 fucntion:      APP_led_pmwdel
 input:
 output:
 describe:  send delete pm2.5&pm10&windspeed program frame
***************************************************/
void APP_led_pmwdel(void)
{
    APP_led_del(TAG_DEL_PRGM, PRGRM_PM, 0, 0);
}
void APP_led_pmwtxtdel(void)
{
    APP_led_del(TAG_DEL_ITEM, PRGRM_PM, 1, 0);
}

/* **************************************************
 fucntion:      APP_led_thndel
 input:
 output:
 describe:  send delete humidity&temperature&noise program frame
***************************************************/
void APP_led_thndel(void)
{
    APP_led_del(TAG_DEL_PRGM, PRGRM_TH, 0, 0);
}
void APP_led_thntxtdel(void)
{
    APP_led_del(TAG_DEL_ITEM, PRGRM_TH, 1, 0);
}
/* **************************************************
 fucntion:      APP_led_noticedel
 input:
 output:
 describe:  send delete humidity&temperature&noise program frame
***************************************************/
void APP_led_noticedel(void)
{
    APP_led_del(TAG_DEL_PRGM, PRGRM_NOTICE, 0, 0);
}
/****************************************************
 fucntion:      APP_led_opt
 input:
 output:
 describe:  send play option frame
***************************************************/
void APP_led_opt(APP_ProgramOption_TypeDef *ptr)
{
    APP_EX30_TypeDef ptlv;
    //uint8_t* buf = led_sendbuf.dat;
    //uint32_t length;

    // ------------ start of update ---------------
    ptlv.len = 0;

    ptlv.serial = led_stat.packnum++;
    ptlv.len += 2;

    ptlv.type = EX30_TYPE;
    ptlv.len ++;

    ptlv.cmd = EX30_CMD_WR;
    ptlv.len ++;

    ptlv.tlvnum = 8;

    // program ID
    ptlv.tlv_buf[0].tag = EX30_TAG_PRGRMID;
    ptlv.len ++;

    ptlv.tlv_buf[0].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[0].len);

    ptlv.tlv_buf[0].value[0] = ptr->programid;    // program ID number
    ptlv.len += ptlv.tlv_buf[0].len;

    // save mode
    ptlv.tlv_buf[1].tag = EX30_TAG_SAV;
    ptlv.len ++;

    ptlv.tlv_buf[1].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[1].len);

    ptlv.tlv_buf[1].value[0] = 0x01;    // save in flash
    ptlv.len += ptlv.tlv_buf[1].len;

    // program propty
    ptlv.tlv_buf[2].tag = EX30_TAG_PRGRMATTR;
    ptlv.len ++;

    ptlv.tlv_buf[2].len = 0x03;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[2].len);

    ptlv.tlv_buf[2].value[0] = 0x00;    // play program in times
    ptlv.tlv_buf[2].value[1] = 0x01;    // play times
    ptlv.tlv_buf[2].value[2] = 0x00;    // second
    ptlv.len += ptlv.tlv_buf[2].len;

    // interval control
    ptlv.tlv_buf[3].tag = EX30_TAG_TIMCTRL;
    ptlv.len ++;

    ptlv.tlv_buf[3].len = 0x0b;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[3].len);

    ptlv.tlv_buf[3].value[0] = 0x00;    // program period
    ptlv.tlv_buf[3].value[1] = 0xD0;
    ptlv.tlv_buf[3].value[2] = 0x07;    // 2007
    ptlv.tlv_buf[3].value[3] = 0x01;    // january
    ptlv.tlv_buf[3].value[4] = 0x01;    // 1st
    ptlv.tlv_buf[3].value[5] = 0x83;
    ptlv.tlv_buf[3].value[6] = 0x08;    // 2179
    ptlv.tlv_buf[3].value[7] = 0x06;    // june
    ptlv.tlv_buf[3].value[8] = 0x05;    // 5th
    ptlv.tlv_buf[3].value[9] = 0x7F;    // monday~sunday
    ptlv.tlv_buf[3].value[10] = 0x00;   // period number
    ptlv.len += ptlv.tlv_buf[3].len;

    // partition ID 0
    ptlv.tlv_buf[4].tag = EX30_TAG_PARTID;
    ptlv.len ++;

    ptlv.tlv_buf[4].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[4].len);

    ptlv.tlv_buf[4].value[0] = 0x00;    // partition ID number
    ptlv.len ++;

    // partition attribution
    ptlv.tlv_buf[5].tag = EX30_TAG_PARTATTR;
    ptlv.len ++;

    ptlv.tlv_buf[5].len = 0x08;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[5].len);

    ptlv.tlv_buf[5].value[0] = 0x00;    // X axis
    ptlv.tlv_buf[5].value[1] = 0x00;
    ptlv.tlv_buf[5].value[2] = 0x00;    // Y axis
    ptlv.tlv_buf[5].value[3] = 0x00;
    ptlv.tlv_buf[5].value[4] = LED_LENGTH&0xff;  // width 96
    ptlv.tlv_buf[5].value[5] = (LED_LENGTH >> 8) & 0xff;
    ptlv.tlv_buf[5].value[6] = LED_WIDTH;   // height 32
    ptlv.tlv_buf[5].value[7] = (LED_WIDTH >> 8) & 0xff;
    ptlv.len += ptlv.tlv_buf[5].len;

    ptlv.len += 2;//checksum size

    APP_led_full(&ptlv);
}

/* **************************************************
 fucntion:      APP_led_upopt
 input:
 output:
 describe:  send pm2.5&pm10 srt play option frame
***************************************************/
void APP_led_upopt(void)
{
    APP_ProgramOption_TypeDef program_opt;

    program_opt.programid = PRGRM_PM;
    program_opt.x = TXT_PM_X;
    program_opt.y = TXT_PM_Y;
    program_opt.width = TXT_PM_W;
    program_opt.height = TXT_PM_H;

    APP_led_opt(&program_opt);
}

/* **************************************************
 fucntion:      APP_led_thopt
 input:
 output:
 describe:  send temperature&humidity srt play option frame
***************************************************/
void APP_led_thopt(void)
{
    APP_ProgramOption_TypeDef program_opt;

    program_opt.programid = PRGRM_TH;
    program_opt.x = TXT_TH_X;
    program_opt.y = TXT_TH_Y;
    program_opt.width = TXT_TH_W;
    program_opt.height = TXT_TH_H;

    APP_led_opt(&program_opt);
}

/* **************************************************
 fucntion:      APP_led_wlopt
 input:
 output:
 describe:  send windspeed & company name srt play option frame
***************************************************/
void APP_led_wlopt(void)
{
    APP_ProgramOption_TypeDef program_opt;

    program_opt.programid = PRGRM_WL;
    program_opt.x = TXT_WL_X;
    program_opt.y = TXT_WL_Y;
    program_opt.width = TXT_WL_W;
    program_opt.height = TXT_WL_H;

    APP_led_opt(&program_opt);
}

/* **************************************************
 fucntion:      APP_led_wnopt
 input:
 output:
 describe:  send windspeed & noise srt play option frame
***************************************************/
void APP_led_wnopt(void)
{
    APP_ProgramOption_TypeDef program_opt;

    program_opt.programid = PRGRM_WN;
    program_opt.x = TXT_WN_X;
    program_opt.y = TXT_WN_Y;
    program_opt.width = TXT_WN_W;
    program_opt.height = TXT_WN_H;

    APP_led_opt(&program_opt);
}

/* **************************************************
 fucntion:      APP_led_flagopt
 input:
 output:
 describe:  send flag srt play option frame
***************************************************/
void APP_led_flagopt(void)
{
    APP_ProgramOption_TypeDef program_opt;

    program_opt.programid = PRGRM_FLAG;
    program_opt.x = TXT_FW_X;
    program_opt.y = TXT_FW_Y;
    program_opt.width = TXT_FW_W;
    program_opt.height = TXT_FW_H;

    APP_led_opt(&program_opt);
}

/* **************************************************
 fucntion:      APP_led_pmwopt
 input:
 output:
 describe:  send pm2.5&pm10&windspeed srt play option frame
***************************************************/
void APP_led_pmwopt(void)
{
    APP_ProgramOption_TypeDef program_opt;

    program_opt.programid = PRGRM_PM;
    program_opt.x = TXT_PMW_X;
    program_opt.y = TXT_PMW_Y;
    program_opt.width = TXT_PMW_W;
    program_opt.height = TXT_PMW_H;

    APP_led_opt(&program_opt);
}

/* **************************************************
 fucntion:      APP_led_thnopt
 input:
 output:
 describe:  send temperature&humidity&noise srt play option frame
***************************************************/
void APP_led_thnopt(void)
{
    APP_ProgramOption_TypeDef program_opt;

    program_opt.programid = PRGRM_TH;
    program_opt.x = TXT_THN_X;
    program_opt.y = TXT_THN_Y;
    program_opt.width = TXT_THN_W;
    program_opt.height = TXT_THN_H;

    APP_led_opt(&program_opt);
}
/* **************************************************
 fucntion:      APP_led_vthnopt
 input:
 output:
 describe:  send temperature&humidity&noise srt play option frame
***************************************************/
void APP_led_vthnopt(void)
{
    APP_ProgramOption_TypeDef program_opt;

    program_opt.programid = PRGRM_TH;
    program_opt.x = TXT_VTHN_X;
    program_opt.y = TXT_VTHN_Y;
    program_opt.width = TXT_VTHN_W;
    program_opt.height = TXT_VTHN_H;

    APP_led_opt(&program_opt);
}
/* **************************************************
 fucntion:      APP_led_noticeopt
 input:
 output:
 describe:  send notice srt play option frame
***************************************************/
void APP_led_noticeopt(void)
{
    APP_EX30_TypeDef ptlv;

    // ------------ start of update ---------------
    ptlv.len = 0;

    ptlv.serial = led_stat.packnum++;
    ptlv.len += 2;

    ptlv.type = EX30_TYPE;
    ptlv.len ++;

    ptlv.cmd = EX30_CMD_WR;
    ptlv.len ++;

    ptlv.tlvnum = 6;

    // program ID
    ptlv.tlv_buf[0].tag = EX30_TAG_PRGRMID;
    ptlv.len ++;

    ptlv.tlv_buf[0].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[0].len);

    ptlv.tlv_buf[0].value[0] = PRGRM_NOTICE;    // program ID number
    ptlv.len += ptlv.tlv_buf[0].len;

    // save mode
    ptlv.tlv_buf[1].tag = EX30_TAG_SAV;
    ptlv.len ++;

    ptlv.tlv_buf[1].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[1].len);

    ptlv.tlv_buf[1].value[0] = 0x01;    // save in flash
    ptlv.len += ptlv.tlv_buf[1].len;

    // program propty
    ptlv.tlv_buf[2].tag = EX30_TAG_PRGRMATTR;
    ptlv.len ++;

    ptlv.tlv_buf[2].len = 0x03;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[2].len);

    ptlv.tlv_buf[2].value[0] = 0x00;    // play program in times
    ptlv.tlv_buf[2].value[1] = 0x01;    // play times
    ptlv.tlv_buf[2].value[2] = 0x00;    // second
    ptlv.len += ptlv.tlv_buf[2].len;

    // interval control
    ptlv.tlv_buf[3].tag = EX30_TAG_TIMCTRL;
    ptlv.len ++;

    ptlv.tlv_buf[3].len = 0x0f;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[3].len);

    ptlv.tlv_buf[3].value[0] = 0x00;    // program period
    ptlv.tlv_buf[3].value[1] = (dustmon_notice.oled_dispchar.year_start)&0xff;   //0xD0;
    ptlv.tlv_buf[3].value[2] = (dustmon_notice.oled_dispchar.year_start >> 8) & 0xff; //0x07;    // 2007
    ptlv.tlv_buf[3].value[3] = dustmon_notice.oled_dispchar.month_start;//0x01;    // january
    ptlv.tlv_buf[3].value[4] = dustmon_notice.oled_dispchar.day_start;//0x01;    // 1st
    ptlv.tlv_buf[3].value[5] = (dustmon_notice.oled_dispchar.year_end) & 0xff; //0x83;
    ptlv.tlv_buf[3].value[6] = (dustmon_notice.oled_dispchar.year_end >> 8) & 0xff;//0x08;    // 2179
    ptlv.tlv_buf[3].value[7] = dustmon_notice.oled_dispchar.month_end;//0x06;    // june
    ptlv.tlv_buf[3].value[8] = dustmon_notice.oled_dispchar.day_end; //0x05;    // 5th
    ptlv.tlv_buf[3].value[9] = dustmon_notice.oled_dispchar.week;//0x7F;    // monday~sunday
    ptlv.tlv_buf[3].value[10] = 0x01;//0x00;   // period number
    ptlv.tlv_buf[3].value[11] = dustmon_notice.oled_dispchar.timeslot_hour_start;
    ptlv.tlv_buf[3].value[12] = dustmon_notice.oled_dispchar.timeslot_min_start;
    ptlv.tlv_buf[3].value[13] = dustmon_notice.oled_dispchar.timeslot_hour_end;
    ptlv.tlv_buf[3].value[14] = dustmon_notice.oled_dispchar.timeslot_min_end;
    ptlv.len += ptlv.tlv_buf[3].len;

    // partition ID 0
    ptlv.tlv_buf[4].tag = EX30_TAG_PARTID;
    ptlv.len ++;

    ptlv.tlv_buf[4].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[4].len);

    ptlv.tlv_buf[4].value[0] = 0x00;    // partition ID number
    ptlv.len ++;

    // partition attribution
    ptlv.tlv_buf[5].tag = EX30_TAG_PARTATTR;
    ptlv.len ++;

    ptlv.tlv_buf[5].len = 0x08;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[5].len);

    ptlv.tlv_buf[5].value[0] = TXT_NOTICE_X & 0xff;    // X axis
    ptlv.tlv_buf[5].value[1] = (TXT_NOTICE_X >> 8) & 0xff;
    ptlv.tlv_buf[5].value[2] = TXT_NOTICE_Y & 0xff;    // Y axis
    ptlv.tlv_buf[5].value[3] = (TXT_NOTICE_Y >> 8) & 0xff;
    ptlv.tlv_buf[5].value[4] = TXT_NOTICE_W & 0xff;  // width
    ptlv.tlv_buf[5].value[5] = (TXT_NOTICE_W >> 8) & 0xff;
    ptlv.tlv_buf[5].value[6] = TXT_NOTICE_H & 0xff; // height
    ptlv.tlv_buf[5].value[7] = (TXT_NOTICE_H >> 8) & 0xff;
    ptlv.len += ptlv.tlv_buf[5].len;

    ptlv.len += 2;//checksum size

    APP_led_full(&ptlv);
}
/* **************************************************
 fucntion:      APP_led_srt
 input:
 output:
 describe:  send subtitle frame
***************************************************/
void APP_led_srt(uint8_t prgm_id,uint8_t *pdata)
{
    APP_EX30_TypeDef ptlv;
    //uint8_t* buf = led_sendbuf.dat;
    //uint32_t length;

    // ------------ start of update ---------------
    ptlv.len = 0;   //  443

    ptlv.serial = led_stat.packnum++;
    ptlv.len += 2;

    ptlv.type = EX30_TYPE;
    ptlv.len ++;

    ptlv.cmd = EX30_CMD_WR;
    ptlv.len ++;

    ptlv.tlvnum = 9;

    // program ID
    ptlv.tlv_buf[0].tag = EX30_TAG_PRGRMID;
    ptlv.len ++;
    ptlv.tlv_buf[0].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[0].len);
    ptlv.tlv_buf[0].value[0] = prgm_id; // program ID number
    ptlv.len += ptlv.tlv_buf[0].len;
    // partition ID 0
    ptlv.tlv_buf[1].tag = EX30_TAG_PARTID;
    ptlv.len ++;
    ptlv.tlv_buf[1].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[1].len);
    ptlv.tlv_buf[1].value[0] = 0x00;    // partition ID number
    ptlv.len += ptlv.tlv_buf[1].len;
    // play item ID 0
    ptlv.tlv_buf[2].tag = EX30_TAG_PLAYITEMID;
    ptlv.len ++;
    ptlv.tlv_buf[2].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[2].len);
    ptlv.tlv_buf[2].value[0] = 0x00;    // play item ID number
    ptlv.len += ptlv.tlv_buf[2].len;
    // data packet property
    ptlv.tlv_buf[3].tag = EX30_TAG_PACKETATTR;
    ptlv.len ++;
    ptlv.tlv_buf[3].len = 0x06;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[3].len);
    ptlv.tlv_buf[3].value[0] = 0x01;    // total packet number
    ptlv.tlv_buf[3].value[1] = 0x00;
    ptlv.tlv_buf[3].value[2] = 0x00;    // current packet number
    ptlv.tlv_buf[3].value[3] = 0x00;
    ptlv.tlv_buf[3].value[4] = 0x00;    // packet length 1024
    ptlv.tlv_buf[3].value[5] = 0x04;
    ptlv.len += ptlv.tlv_buf[3].len;
    // save mode
    ptlv.tlv_buf[4].tag = EX30_TAG_SAV;
    ptlv.len ++;
    ptlv.tlv_buf[4].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[4].len);
    ptlv.tlv_buf[4].value[0] = 0x01;    // save in flash
    ptlv.len += ptlv.tlv_buf[4].len;
    // play item special effect
    ptlv.tlv_buf[5].tag = EX30_TAG_PLAYITEMSPEC;
    ptlv.len ++;
    ptlv.tlv_buf[5].len = 0x03;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[5].len);
    ptlv.tlv_buf[5].value[0] = 0x01;    // immediately display
    ptlv.tlv_buf[5].value[1] = 0x09;    // specail effect grade
    ptlv.tlv_buf[5].value[2] = 0x05;    // stay 5 seconds
    ptlv.len += ptlv.tlv_buf[5].len;
    // play item attribution
    ptlv.tlv_buf[6].tag = EX30_TAG_PLAYITEMATTR;
    ptlv.len ++;
    ptlv.tlv_buf[6].len = 0x10;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[6].len);
    ptlv.tlv_buf[6].value[0] = 0x00;    // 定次播放
    ptlv.tlv_buf[6].value[1] = 0x01;    // 播放次数
    ptlv.tlv_buf[6].value[2] = 0x00;
    ptlv.tlv_buf[6].value[3] = 0x01;    // 图片
    ptlv.tlv_buf[6].value[4] = 0x00;    // 数据组织方式
    ptlv.tlv_buf[6].value[5] = 0x01;    // 单基色图片
    ptlv.tlv_buf[6].value[6] = LED_LENGTH&0xff;  // width 96
    ptlv.tlv_buf[6].value[7] = (LED_LENGTH >> 8) & 0xff;
    ptlv.tlv_buf[6].value[8] = LED_WIDTH;   // height 32 or 64
    ptlv.tlv_buf[6].value[9] = (LED_WIDTH >> 8) & 0xff;
    ptlv.tlv_buf[6].value[10] = 0x01;   // 图片页数 1
    ptlv.tlv_buf[6].value[11] = 0x00;
    ptlv.tlv_buf[6].value[12] = 0xFF;   // 非GIF
    ptlv.tlv_buf[6].value[13] = 0xFF;
    ptlv.tlv_buf[6].value[14] = 0x00;   // 最后一页字幕有效长度
    ptlv.tlv_buf[6].value[15] = 0x00;
    ptlv.len += ptlv.tlv_buf[6].len;
    // 实时刷新
    ptlv.tlv_buf[7].tag = EX30_TAG_UPDAT;
    ptlv.len ++;
    ptlv.tlv_buf[7].len = 0x04;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[7].len);
    ptlv.tlv_buf[7].value[0] = 0x02;    // play item
    ptlv.tlv_buf[7].value[1] = prgm_id; // program ID 0
    ptlv.tlv_buf[7].value[2] = 0x00;    // partition ID 0
    ptlv.tlv_buf[7].value[3] = 0x00;    // play item ID 0
    ptlv.len += ptlv.tlv_buf[7].len;
    // data packet
    ptlv.tlv_buf[8].tag = EX30_TAG_PACKET;
    ptlv.len ++;
    ptlv.tlv_buf[8].len = LED_LENGTH * LED_WIDTH / 8; //0x180;      // 384
    ptlv.len += get_TLV_length(ptlv.tlv_buf[8].len);
    for (uint16_t i = 0; i < ptlv.tlv_buf[8].len; i++)
    {
        ptlv.tlv_buf[8].value[i] = pdata[i];
    }
    ptlv.len += ptlv.tlv_buf[8].len;

    ptlv.len += 2; // checksum

    APP_led_full(&ptlv);
}

/* **************************************************
 fucntion:      APP_led_upsrt
 input:
 output:
 describe:  send pm2.5&pm10 subtitle frame
***************************************************/
void APP_led_upsrt(void)
{
    APP_led_srt(PRGRM_PM, (uint8_t *)SRT_PM);
}

/* **************************************************
 fucntion:      APP_led_thsrt
 input:
 output:
 describe:  send temperature&humidity subtitle frame
***************************************************/
void APP_led_thsrt(void)
{
    APP_led_srt(PRGRM_TH, (uint8_t *)SRT_TH);
}

/* **************************************************
 fucntion:      APP_led_wlsrt
 input:
 output:
 describe:  send windspeed & company name subtitle frame
***************************************************/
void APP_led_wlsrt(void)
{
    APP_led_srt(PRGRM_WL, (uint8_t *)SRT_WIND);
}

/* **************************************************
 fucntion:      APP_led_wnsrt
 input:
 output:
 describe:  send windspeed & noise subtitle frame
***************************************************/
void APP_led_wnsrt(void)
{
    if (dustmon_info.soundsensor_en)
    {
        APP_led_srt(PRGRM_WN, (uint8_t *)SRT_WN);
    }
    else
    {
        APP_led_srt(PRGRM_WN, (uint8_t *)SRT_WIND);
    }

}

/* **************************************************
 fucntion:      APP_led_flagsrt
 input:
 output:
 describe:  扬尘在线监控
            专业治污除霾
                            subtitle frame
***************************************************/
void APP_led_flagsrt(void)
{
    APP_led_srt(PRGRM_FLAG, (uint8_t *)SRT_FLAG);
}



/* **************************************************
 fucntion:      APP_led_pmwsrt
 input:
 output:
 describe:  send pm2.5&pm10&windspeed subtitle frame
***************************************************/
void APP_led_pmwsrt(void)
{
    APP_led_srt(PRGRM_PM, (uint8_t *)SRT_PMW);
}

/* **************************************************
 fucntion:      APP_led_thnsrt
 input:
 output:
 describe:  send temperature &
                 humidity &
                 noise subtitle frame
***************************************************/
void APP_led_thnsrt(void)
{
    APP_led_srt(PRGRM_TH, (uint8_t *)SRT_THN);
}

/* **************************************************
 fucntion:      APP_led_uptxt
 input:
 output:
 describe:  send pm txt frame
***************************************************/

void APP_led_txt(uint8_t prgm_id, uint8_t part_id, uint8_t item_id, uint8_t *str)
{
    APP_EX30_TypeDef ptlv;
    //uint8_t* buf = led_sendbuf.dat;
    uint16_t length;

    // ------------ start of update ---------------
    length = (uint16_t)strlen((const char *)str);

    ptlv.len = 0;

    ptlv.serial = led_stat.packnum++;
    ptlv.len += 2;

    ptlv.type = EX30_TYPE;
    ptlv.len ++;

    ptlv.cmd = EX30_CMD_WR;
    ptlv.len ++;

    ptlv.tlvnum = 9;

    // program ID
    ptlv.tlv_buf[0].tag = EX30_TAG_PRGRMID;
    ptlv.len ++;
    ptlv.tlv_buf[0].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[0].len);
    ptlv.tlv_buf[0].value[0] = prgm_id; // program ID number
    ptlv.len += ptlv.tlv_buf[0].len;
    // partition ID 0
    ptlv.tlv_buf[1].tag = EX30_TAG_PARTID;
    ptlv.len ++;
    ptlv.tlv_buf[1].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[1].len);
    ptlv.tlv_buf[1].value[0] = 0x01;    // partition ID number
    ptlv.len += ptlv.tlv_buf[1].len;
    // play item ID 0
    ptlv.tlv_buf[2].tag = EX30_TAG_PLAYITEMID;
    ptlv.len ++;
    ptlv.tlv_buf[2].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[2].len);
    ptlv.tlv_buf[2].value[0] = 0x00;    // play item ID number
    ptlv.len += ptlv.tlv_buf[2].len;
    // data packet property
    ptlv.tlv_buf[3].tag = EX30_TAG_PACKETATTR;
    ptlv.len ++;
    ptlv.tlv_buf[3].len = 0x06;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[3].len);
    ptlv.tlv_buf[3].value[0] = 0x01;    // total packet number
    ptlv.tlv_buf[3].value[1] = 0x00;
    ptlv.tlv_buf[3].value[2] = 0x00;    // current packet number
    ptlv.tlv_buf[3].value[3] = 0x00;
    ptlv.tlv_buf[3].value[4] = 0x00;    // packet length 1024
    ptlv.tlv_buf[3].value[5] = 0x04;
    ptlv.len += ptlv.tlv_buf[3].len;
    // save mode
    ptlv.tlv_buf[4].tag = EX30_TAG_SAV;
    ptlv.len ++;
    ptlv.tlv_buf[4].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[4].len);
    ptlv.tlv_buf[4].value[0] = 0x00;    // save in flash
    ptlv.len += ptlv.tlv_buf[4].len;
    // play item special effect
    ptlv.tlv_buf[5].tag = EX30_TAG_PLAYITEMSPEC;
    ptlv.len ++;
    ptlv.tlv_buf[5].len = 0x03;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[5].len);
    ptlv.tlv_buf[5].value[0] = 0x01;    // immediately display
    ptlv.tlv_buf[5].value[1] = 0x09;    // specail effect grade
    ptlv.tlv_buf[5].value[2] = 0x05;    // stay 5 seconds
    ptlv.len += ptlv.tlv_buf[5].len;
    // play item attribution
    ptlv.tlv_buf[6].tag = EX30_TAG_PLAYITEMATTR;
    ptlv.len ++;
    ptlv.tlv_buf[6].len = 0x0A;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[6].len);
    ptlv.tlv_buf[6].value[0] = 0x00;    // 定次播放
    ptlv.tlv_buf[6].value[1] = 0x01;    // 播放次数
    ptlv.tlv_buf[6].value[2] = 0x00;
    ptlv.tlv_buf[6].value[3] = 0x00;    // 文本
    ptlv.tlv_buf[6].value[4] = 0x00;    // GB2312
    ptlv.tlv_buf[6].value[5] = 0x10;    // 字体大小16
    ptlv.tlv_buf[6].value[6] = 0x01;    // 红色
    ptlv.tlv_buf[6].value[7] = 0x00;    // 字体0（宋体）
    ptlv.tlv_buf[6].value[8] = 0x00;    // 文本连续移动时首尾相连距离
    ptlv.tlv_buf[6].value[9] = 0x00;
    ptlv.len += ptlv.tlv_buf[6].len;
    // 实时刷新
    ptlv.tlv_buf[7].tag = EX30_TAG_UPDAT;
    ptlv.len ++;
    ptlv.tlv_buf[7].len = 0x04;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[7].len);
    ptlv.tlv_buf[7].value[0] = 0x02;        // play item
    ptlv.tlv_buf[7].value[1] = prgm_id;     // program ID 0
    ptlv.tlv_buf[7].value[2] = part_id;     // partition ID 1
    ptlv.tlv_buf[7].value[3] = item_id;     // play item ID 0
    ptlv.len += ptlv.tlv_buf[7].len;
    // data packet
    ptlv.tlv_buf[8].tag = EX30_TAG_PACKET;
    ptlv.len ++;
    ptlv.tlv_buf[8].len = length;      // 7
    ptlv.len += get_TLV_length(ptlv.tlv_buf[8].len);
    // 此处添加字符串
    for (uint16_t i = 0; i < length; i++)
    {
        ptlv.tlv_buf[8].value[i] = str[i];
    }
    ptlv.len += ptlv.tlv_buf[8].len;

    ptlv.len += 2;  //checksum size

    APP_led_full(&ptlv);
}

/* **************************************************
 fucntion:      APP_led_uptxt
 input:
 output:
 describe:  send pm2.5 & pm10 txt frame
***************************************************/
void APP_led_uptxt(void)
{
    uint8_t pmstr[10];
    //
    APP_led_upf2a(sensor_value[SENS_UPWEIGHT].value, pmstr);
    APP_led_txt(PRGRM_PM, PART_TXT, ITEM_TXT, pmstr);
}

/* **************************************************
 fucntion:      APP_led_thtxt
 input:
 output:
 describe:  send temperature & humidity txt frame
***************************************************/
void APP_led_thtxt(void)
{
    uint8_t thstr[10];
    //
    APP_led_thf2a(sensor_value[SENS_TEMP].value, sensor_value[SENS_HMDT].value, thstr);
    //APP_led_thf2a(temperature, humidity, thstr);
    APP_led_txt(PRGRM_TH, PART_TXT, ITEM_TXT,thstr);
}

/* **************************************************
 fucntion:      APP_led_wltxt
 input:
 output:
 describe:  send windspeed & company name txt frame
***************************************************/
void APP_led_wltxt(void)
{
    uint8_t wlstr[5];
    //
    APP_led_wlf2a(sensor_value[SENS_WIND].value, wlstr);
    APP_led_txt(PRGRM_WL, PART_TXT, ITEM_TXT,wlstr);
}


/* **************************************************
 fucntion:      APP_led_wntxt
 input:
 output:
 describe:  send windspeed & noise txt frame
***************************************************/
void APP_led_wntxt(void)
{
    uint8_t wnstr[10];
    //
    APP_led_wnf2a(sensor_value[SENS_WIND].value, 35 * log10(0.00523f*sensor_value[SENS_NOISE].value+4.708f) + 25, wnstr);
    APP_led_txt(PRGRM_WN, PART_TXT, ITEM_TXT,wnstr);
}
/* **************************************************
 fucntion:      APP_led_vanetxt
 input:
 output:
 describe:  send wind vane txt frame
***************************************************/
void APP_led_vanetxt(void)
{
    uint8_t vanestr[10];
    //
    APP_led_vanef2a(sensor_value[SENS_VANE].value, vanestr);
    APP_led_txt(PRGRM_FLAG, PART_TXT, ITEM_TXT, vanestr);
}

/* **************************************************
 fucntion:      APP_led_pmwtxt
 input:
 output:
 describe:  send pm2.5 & pm10 & windspeed txt frame
***************************************************/
void APP_led_pmwtxt(void)
{
    uint8_t pmstr[15];
    //
    APP_led_pmwf2a(sensor_value[SENS_PM25].value, sensor_value[SENS_PM10].value, sensor_value[SENS_WIND].value, pmstr);
    APP_led_txt(PRGRM_PM, PART_TXT, ITEM_TXT, pmstr);
}

/* **************************************************
 fucntion:      APP_led_thtxt
 input:
 output:
 describe:  send vane & temperature & humidity & noise txt frame
***************************************************/
void APP_led_thntxt(void)
{
    uint8_t thstr[40];
    //
    //APP_led_thnf2a(sensor_value[SENS_TEMP].value, sensor_value[SENS_HMDT].value, 35 * log10(0.00523*sensor_value[SENS_NOISE].value+4.708) + 25, thstr);
    APP_led_vthnf2a(sensor_value[SENS_VANE].value,
                    sensor_value[SENS_TEMP].value,
                    sensor_value[SENS_HMDT].value,
                    35 * log10(0.00523f*sensor_value[SENS_NOISE].value+4.708f) + 25,
                    thstr);
    APP_led_txt(PRGRM_TH, PART_TXT, ITEM_TXT,thstr);
}

/* **************************************************
 fucntion:      APP_led_noticetxt
 input:
 output:
 describe:  send vane & temperature & humidity & noise txt frame
***************************************************/
void APP_led_noticetxt(void)
{
    APP_EX30_TypeDef ptlv;
    //uint8_t* buf = led_sendbuf.dat;
    uint16_t length;

    // ------------ start of update ---------------
    length = (uint16_t)strlen((const char *)dustmon_notice.oled_dispchar.display_char);

    ptlv.len = 0;

    ptlv.serial = led_stat.packnum++;
    ptlv.len += 2;

    ptlv.type = EX30_TYPE;
    ptlv.len ++;

    ptlv.cmd = EX30_CMD_WR;
    ptlv.len ++;

    ptlv.tlvnum = 9;

    // program ID
    ptlv.tlv_buf[0].tag = EX30_TAG_PRGRMID;
    ptlv.len ++;
    ptlv.tlv_buf[0].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[0].len);
    ptlv.tlv_buf[0].value[0] = PRGRM_NOTICE; // program ID number
    ptlv.len += ptlv.tlv_buf[0].len;
    // partition ID 0
    ptlv.tlv_buf[1].tag = EX30_TAG_PARTID;
    ptlv.len ++;
    ptlv.tlv_buf[1].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[1].len);
    ptlv.tlv_buf[1].value[0] = 0x00;    // partition ID number
    ptlv.len += ptlv.tlv_buf[1].len;
    // play item ID 0
    ptlv.tlv_buf[2].tag = EX30_TAG_PLAYITEMID;
    ptlv.len ++;
    ptlv.tlv_buf[2].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[2].len);
    ptlv.tlv_buf[2].value[0] = 0x00;    // play item ID number
    ptlv.len += ptlv.tlv_buf[2].len;
    // data packet property
    ptlv.tlv_buf[3].tag = EX30_TAG_PACKETATTR;
    ptlv.len ++;
    ptlv.tlv_buf[3].len = 0x06;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[3].len);
    ptlv.tlv_buf[3].value[0] = 0x01;    // total packet number
    ptlv.tlv_buf[3].value[1] = 0x00;
    ptlv.tlv_buf[3].value[2] = 0x00;    // current packet number
    ptlv.tlv_buf[3].value[3] = 0x00;
    ptlv.tlv_buf[3].value[4] = 0x00;    // packet length 1024
    ptlv.tlv_buf[3].value[5] = 0x04;
    ptlv.len += ptlv.tlv_buf[3].len;
    // save mode
    ptlv.tlv_buf[4].tag = EX30_TAG_SAV;
    ptlv.len ++;
    ptlv.tlv_buf[4].len = 0x01;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[4].len);
    ptlv.tlv_buf[4].value[0] = 0x00;    // save in flash
    ptlv.len += ptlv.tlv_buf[4].len;
    // play item special effect
    ptlv.tlv_buf[5].tag = EX30_TAG_PLAYITEMSPEC;
    ptlv.len ++;
    ptlv.tlv_buf[5].len = 0x03;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[5].len);
    ptlv.tlv_buf[5].value[0] = 0x01;    // immediately display
    ptlv.tlv_buf[5].value[1] = 0x09;    // specail effect grade
    ptlv.tlv_buf[5].value[2] = 0x05;    // stay 5 seconds
    ptlv.len += ptlv.tlv_buf[5].len;
    // play item attribution
    ptlv.tlv_buf[6].tag = EX30_TAG_PLAYITEMATTR;
    ptlv.len ++;
    ptlv.tlv_buf[6].len = 0x0A;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[6].len);
    ptlv.tlv_buf[6].value[0] = 0x00;    // 定次播放
    ptlv.tlv_buf[6].value[1] = 0x01;    // 播放次数
    ptlv.tlv_buf[6].value[2] = 0x00;
    ptlv.tlv_buf[6].value[3] = 0x00;    // 文本
    ptlv.tlv_buf[6].value[4] = 0x00;    // GB2312
    ptlv.tlv_buf[6].value[5] = 0x10;    // 字体大小16
    ptlv.tlv_buf[6].value[6] = 0x01;    // 红色
    ptlv.tlv_buf[6].value[7] = 0x00;    // 字体0（宋体）
    ptlv.tlv_buf[6].value[8] = 0x00;    // 文本连续移动时首尾相连距离
    ptlv.tlv_buf[6].value[9] = 0x00;
    ptlv.len += ptlv.tlv_buf[6].len;
    // 实时刷新
    ptlv.tlv_buf[7].tag = EX30_TAG_UPDAT;
    ptlv.len ++;
    ptlv.tlv_buf[7].len = 0x04;
    ptlv.len += get_TLV_length(ptlv.tlv_buf[7].len);
    ptlv.tlv_buf[7].value[0] = 0x02;        // play item
    ptlv.tlv_buf[7].value[1] = PRGRM_NOTICE;     // program ID 0
    ptlv.tlv_buf[7].value[2] = 0;     // partition ID 1
    ptlv.tlv_buf[7].value[3] = 0;     // play item ID 0
    ptlv.len += ptlv.tlv_buf[7].len;
    // data packet
    ptlv.tlv_buf[8].tag = EX30_TAG_PACKET;
    ptlv.len ++;
    ptlv.tlv_buf[8].len = length;      // 7
    ptlv.len += get_TLV_length(ptlv.tlv_buf[8].len);
    // 此处添加字符串
    for (uint16_t i = 0; i < length; i++)
    {
        ptlv.tlv_buf[8].value[i] = dustmon_notice.oled_dispchar.display_char[i];
    }
    ptlv.len += ptlv.tlv_buf[8].len;

    ptlv.len += 2;  //checksum size

    APP_led_full(&ptlv);
}

/* **************************************************
 fucntion:      APP_led_task
 input:
 output:
 describe:  led task
***************************************************/
void APP_led_task(void)
{
    enum
    {
        LED_STEP_LINK = 0, // communicate with ex-30
        LED_STEP_SETRTC,
        LED_STEP_PRGMDEL,
        LED_STEP_SETSRC,    // set screen parameter
        LED_STEP_SETLIGHT,  // set lightness
        LED_STEP_UPDEL,  // delete program for uploading screen
        LED_STEP_UPOPT,  // set uploading screen option
        LED_STEP_UPSCR,  // send uploading subtitle screen
        LED_STEP_DELUPTXT,
        LED_STEP_UPTXT,  // display uploading data
        LED_STEP_DELAY15,

        LED_STEP_MAX
    };

    static uint8_t step = LED_STEP_LINK;
    static uint32_t timestamp = 0,cnt = 0;
    uint32_t tick;
    tick = HAL_GetTick();
/* 
    if ((tick - timestamp) > 5000)
    {
        step = LED_STEP_LINK;
        led_sendbuf.busy = FALSE;
        led_stat.packnum = 0;
    }
    timestamp = tick;
*/
    if (led_sendbuf.busy)
    {
        cnt++;
        if (cnt >= 100)
        {
            cnt = 0;
            //step = LED_STEP_LINK;
            led_sendbuf.busy = FALSE;
            //led_stat.packnum = 0;
        }
        return;
    }
    else cnt = 0;

    switch (step)
    {
    case LED_STEP_LINK:
        APP_led_connect();
        step = LED_STEP_SETRTC;
        break;
    case LED_STEP_SETRTC:
        APP_led_setsrcrtc();
        step = LED_STEP_PRGMDEL;
        break;
    case LED_STEP_PRGMDEL:
        APP_led_prgmdel();
        step = LED_STEP_SETSRC;
        break;
    case LED_STEP_SETSRC:
        APP_led_setsrccfg();
        step = LED_STEP_SETLIGHT;
        break;
    case LED_STEP_SETLIGHT:
        APP_led_setlight();
        step = LED_STEP_UPDEL;
        break;
    case LED_STEP_UPDEL:
        APP_led_updel();
        step = LED_STEP_UPOPT;
        break;
    case LED_STEP_UPOPT:
        APP_led_upopt();
        step = LED_STEP_UPSCR;
        break;
    case LED_STEP_UPSCR:
        APP_led_upsrt();
        step = LED_STEP_DELUPTXT;
        break;
    case LED_STEP_DELUPTXT:
        APP_led_uptxtdel();
        step = LED_STEP_UPTXT;
        break;
    case LED_STEP_UPTXT:
        if (sensor_value[SENS_UPWEIGHT].valid)
        {
            APP_led_uptxt();
        }
        step = LED_STEP_DELAY15;
        break;
    case LED_STEP_DELAY15:
        if ((tick - timestamp) > 1000)
        {
            step = LED_STEP_DELUPTXT;
        }
        break;
    default:
        step = LED_STEP_LINK;
        led_sendbuf.busy = FALSE;
        led_stat.packnum = 0;

        break;
    }
}

/****************************************************
 fucntion:      APP_led_task1
 input:
 output:
 describe:      四行两屏
***************************************************/
void APP_led_task1(void)
{
    enum
    {
        LED_STEP_LINK = 0, // communicate with ex-30
        LED_STEP_SETRTC,
        LED_STEP_PRGMDEL,
        LED_STEP_SETSRC,    // set screen parameter
        LED_STEP_SETLIGHT,  // set lightness
        LED_STEP_PMWDEL,  // delete program for pm screen
        LED_STEP_PMWOPT,  // set pm screen option
        LED_STEP_PMWSCR,  // send pm2.5&pm1.0 subtitle screen
        LED_STEP_THNDEL,   // delete program for temperature & humidity screen
        LED_STEP_THNOPT,  // set temperature & humidity screen option
        LED_STEP_THNSCR,  // send temperature & humidity subtitle screen
        LED_STEP_NOTICEDEL, // delete notice
        LED_STEP_NOTICEOPT, // set notice option
        LED_STEP_NOTICETXT, // display notice
        LED_STEP_DELPMWTXT,
        LED_STEP_PMWTXT,  // display pm2.5&pm10 data
        LED_STEP_DELTHNTXT,
        LED_STEP_THNTXT,  // display temperature & humidity data
        LED_STEP_NOTICECLR, // clear oled notice
        LED_STEP_NOTICEOPT1,
        LED_STEP_NOTICEUPDATE,  // update notice
        LED_STEP_DELAY15,

        LED_STEP_MAX
    };

    static uint8_t step = LED_STEP_LINK;
    static uint32_t timestamp = 0,cnt = 0;
    uint32_t tick;
    tick = HAL_GetTick();
/* 
    if ((tick - timestamp) > 5000)
    {
        step = LED_STEP_LINK;
        led_sendbuf.busy = FALSE;
        led_stat.packnum = 0;
    }
    timestamp = tick;
*/
    if (led_sendbuf.busy)
    {
        cnt++;
        if (cnt >= 100)
        {
            cnt = 0;
            //step = LED_STEP_LINK;
            led_sendbuf.busy = FALSE;
            //led_stat.packnum = 0;
        }
        return;
    }
    else cnt = 0;

    switch (step)
    {
    case LED_STEP_LINK:
        APP_led_connect();
        step = LED_STEP_SETRTC;
        break;
    case LED_STEP_SETRTC:
        APP_led_setsrcrtc();
        step = LED_STEP_PRGMDEL;
        break;
    case LED_STEP_PRGMDEL:
        APP_led_prgmdel();
        step = LED_STEP_SETSRC;
        break;
    case LED_STEP_SETSRC:
        APP_led_setsrccfg();
        step = LED_STEP_SETLIGHT;
        break;
    case LED_STEP_SETLIGHT:
        APP_led_setlight();
        step = LED_STEP_PMWDEL;
        break;
    case LED_STEP_PMWDEL:
        APP_led_pmwdel();
        step = LED_STEP_PMWOPT;
        break;
    case LED_STEP_PMWOPT:
        APP_led_pmwopt();
        step = LED_STEP_PMWSCR;
        break;
    case LED_STEP_PMWSCR:
        APP_led_pmwsrt();
        step = LED_STEP_THNDEL;
        break;
    case LED_STEP_THNDEL:
        APP_led_thndel();
        step = LED_STEP_THNOPT;
        break;
    case LED_STEP_THNOPT:
        //APP_led_thnopt();
        APP_led_vthnopt();
        step = LED_STEP_THNSCR;
        break;
    case LED_STEP_THNSCR:
        APP_led_thnsrt();
        step = LED_STEP_NOTICEDEL;
        break;
    case LED_STEP_NOTICEDEL:
        if (dustmon_notice.oled_update)
        {
            dustmon_notice.oled_update = FALSE;
            APP_led_noticedel();
            step = LED_STEP_NOTICEOPT;
        }
        else
        {
            step = LED_STEP_DELPMWTXT;
        }
        break;
    case LED_STEP_NOTICEOPT:
        APP_led_noticeopt();
        step = LED_STEP_NOTICETXT;
        break;
    case LED_STEP_NOTICETXT:
        APP_led_noticetxt();
        step = LED_STEP_DELPMWTXT;
        break;
    case LED_STEP_DELPMWTXT:
        APP_led_pmwtxtdel();
        step = LED_STEP_PMWTXT;
        break;
    case LED_STEP_PMWTXT:
        if (sensor_value[SENS_PM25].valid && sensor_value[SENS_PM10].valid)
        {
            APP_led_pmwtxt();
        }
        step = LED_STEP_DELTHNTXT;
        break;
    case LED_STEP_DELTHNTXT:
        APP_led_thntxtdel();
        step = LED_STEP_THNTXT;
        break;
    case LED_STEP_THNTXT:
        if (sensor_value[SENS_TEMP].valid && sensor_value[SENS_HMDT].valid)
        {
            APP_led_thntxt();
        }
        step = LED_STEP_DELAY15;
        timestamp = tick;
        break;
    case LED_STEP_DELAY15:
        if ((tick - timestamp) > 1000)
        {
            step = LED_STEP_NOTICEDEL;
        }
        break;
    default:
        step = LED_STEP_LINK;
        led_sendbuf.busy = FALSE;
        led_stat.packnum = 0;

        break;
    }
}

/* **************************************************
 fucntion:      APP_led_pmf2a
 input:
 output:
 describe:  translate pm value to ascii
***************************************************/

void APP_led_pmf2a(float pm25_dat, float pm10_dat, uint8_t *buf)
{
    uint8_t asc[10];
    static uint32_t temp;

    temp = (pm25_dat > 999)? 999 : pm25_dat;

    asc[0] =  (temp /100);
    asc[1] =  (temp / 10 % 10);
    asc[2] =  (temp % 10);

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    if (asc[0] == 0 && asc[1] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[1] + 0x30;

    *buf++ = asc[2] + 0x30;

    *buf++ = 0x20;

    temp = (pm10_dat > 999)? 999 : pm10_dat;

    asc[0] =  (temp /100);
    asc[1] =  (temp /10 % 10);
    asc[2] =  (temp % 10);

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    if (asc[0] == 0 && asc[1] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[1] + 0x30;

    *buf++ = asc[2] + 0x30;

    *buf = 0;
}

/* **************************************************
 fucntion:      APP_led_upf2a
 input:
 output:
 describe:  translate uploading weight value to ascii
***************************************************/

void APP_led_upf2a(float up_dat, uint8_t *buf)
{
    static uint8_t asc[10];
    static uint32_t temp;

    temp = (up_dat > 99999)? 99999 : up_dat;

    //pop(asc, temp);

    asc[0] = (temp / 10000 % 10);
    asc[1] = (temp / 1000 % 10);
    asc[2] = (temp / 100 % 10);
    asc[3] = (temp / 10 % 10);
    asc[4] = (temp % 10);     

    //*buf++ = 0x20;
    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    if (asc[0] == 0 && asc[1] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[1] + 0x30;

    if (asc[0] == 0 && asc[1] == 0 && asc[2] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[2] + 0x30;

    if (asc[0] == 0 && asc[1] == 0 && asc[2] == 0 && asc[3] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[3] + 0x30;

    *buf++ = asc[4] + 0x30;
    *buf++ = ' ';
    *buf++ = 'k';
    *buf++ = 'g';

    *buf = 0;
}

/* **************************************************
 fucntion:      APP_led_thf2a
 input:
 output:
 describe:  translate temperatrue & humidity value to ascii
***************************************************/

void APP_led_thf2a(float v_temp, float v_humi, uint8_t *buf)
{
    uint8_t asc[10];
    static uint32_t temp;
    float tv,hv;

    tv = v_temp*10.0f;
    // test limit -40~+80
    if (tv < -400) tv = -400;
    if (tv > 800) tv = 800;

    if (tv < 0)
    {
        temp = -tv;
    }
    else temp = tv;

    if (v_temp < 0) // 零下
    {
        asc[0] = '-';
        asc[1] = (temp / 100);
        asc[2] = (temp / 10 % 10);
        asc[3] = (temp % 10);
    }
    else    // 零上
    {
        asc[0] = 0;
        asc[1] = (temp / 100);
        asc[2] = (temp / 10 % 10);
        asc[3] = (temp % 10);
    }

    // 符号位
    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else if (asc[0] == '-')
    {
        *buf++ = '-';
    }
    else *buf++ = asc[0] + 0x30;

    // 最高位
    if (asc[1] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[1] + 0x30;

    // 次高位
    *buf++ = asc[2] + 0x30;

    // 小数点位
    *buf++ = '.';

    // 小数位
    *buf++ = asc[3] + 0x30;


    // 湿度
    hv = v_humi * 10.0f;
    // test limit 0~100
    if (hv < 0) hv = 0;
    if (hv > 999) hv = 999;

    temp = hv;

    asc[0] = (temp / 100);
    asc[1] = (temp / 10 % 10);
    asc[2] = (temp % 10);

    *buf++ = ' ';

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    *buf++ = asc[1] + 0x30;

    *buf++ = '.';

    *buf++ = asc[2] + 0x30;

    *buf = 0;
}


/* **************************************************
 fucntion:      APP_led_wlf2a
 input:
 output:
 describe:  translate wind speed value to ascii
***************************************************/

void APP_led_wlf2a(float windspeed, uint8_t *buf)
{
    uint8_t asc[10];
    static uint32_t temp;
    float ws;

    ws = windspeed*10.0f;
    temp = (ws > 999)? 999 : ws;

    asc[0] =  (temp /100);
    asc[1] =  (temp /10 % 10);
    asc[2] =  (temp % 10);

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    *buf++ = asc[1] + 0x30;

    *buf++ = '.';

    *buf++ = asc[2] + 0x30;

    *buf = 0;
}

/* **************************************************
 fucntion:      APP_led_wnf2a
 input:
 output:
 describe:  translate wind speed & noise value to ascii
***************************************************/

void APP_led_wnf2a(float windspeed, float noise, uint8_t *buf)
{
    uint8_t asc[10];
    static uint32_t temp;
    float ws,ns;

    ws = windspeed*10.0f;
    temp = (ws > 999)? 999 : ws;

    asc[0] =  (temp /100);
    asc[1] =  (temp /10 % 10);
    asc[2] =  (temp % 10);

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    *buf++ = asc[1] + 0x30;

    *buf++ = '.';

    *buf++ = asc[2] + 0x30;

    *buf++ = 0x20;

    // 噪声
    if (!dustmon_info.soundsensor_en)
    {
        *buf++ = ' ';
        *buf++ = ' ';
        *buf++ = ' ';
        *buf++ = ' ';
        *buf++ = ' ';
        *buf = 0;
        return;
    }
    ns = noise * 10.0f;
    // test limit 30~130
    if (ns < 300) ns = 300;
    if (ns > 1300) ns = 1300;
    temp = ns;

    asc[0] = (temp / 1000);
    asc[1] = (temp / 100 % 10);
    asc[2] = (temp / 10 % 10);
    asc[3] = (temp % 10);

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    if (asc[1] == 0 && asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[1] + 0x30;

    *buf++ = asc[2] + 0x30;

    *buf++ = '.';

    *buf++ = asc[3] + 0x30;

    *buf = 0;
}

/* **************************************************
 fucntion:      APP_led_vanef2a
 input:
 output:
 describe:  translate wind vane value to ascii
***************************************************/

void APP_led_vanef2a(float v_vane, uint8_t *buf)
{
    //uint8_t asc[15];
    //static uint32_t temp;
    //float tv,hv,ns;

    //tv = v_vane;
    if ((v_vane >= 348.75f && v_vane < 360.0f) || (v_vane >= 0.0f && v_vane < 11.25f)) strcpy((char *)buf, "   北  ");
    else if (v_vane >= 11.25f && v_vane < 33.75f) strcpy((char *)buf, " 北东北");
    else if (v_vane >= 33.75f && v_vane < 56.25f) strcpy((char *)buf, "   东北");
    else if (v_vane >= 56.25f && v_vane < 78.75f) strcpy((char *)buf, " 东东北");
    else if (v_vane >=  78.75f && v_vane <101.25f) strcpy((char *)buf,"   东  ");
    else if (v_vane >= 101.25f && v_vane <123.75f) strcpy((char *)buf," 东东南");
    else if (v_vane >= 123.75f && v_vane <146.25f) strcpy((char *)buf,"   东南");
    else if (v_vane >= 146.25f && v_vane <168.75f) strcpy((char *)buf," 南东南");
    else if (v_vane >= 168.75f && v_vane <191.25f) strcpy((char *)buf,"   南  ");
    else if (v_vane >= 191.25f && v_vane <213.75f) strcpy((char *)buf," 南西南");
    else if (v_vane >= 213.75f && v_vane <236.25f) strcpy((char *)buf,"   西南");
    else if (v_vane >= 236.25f && v_vane <258.75f) strcpy((char *)buf," 西西南");
    else if (v_vane >= 258.75f && v_vane <281.25f) strcpy((char *)buf,"   西  ");
    else if (v_vane >= 281.25f && v_vane <303.75f) strcpy((char *)buf," 西西北");
    else if (v_vane >= 303.75f && v_vane <326.25f) strcpy((char *)buf,"   西北");
    else if (v_vane >= 326.25f && v_vane <348.75f) strcpy((char *)buf," 北西北");
    else strcpy((char *)buf, "       ");
    buf += 7;

    *buf = 0;
}

/* **************************************************
 fucntion:      APP_led_pmwf2a
 input:
 output:
 describe:  translate pm & windspeed value to ascii
***************************************************/

void APP_led_pmwf2a(float pm25_dat, float pm10_dat, float windspeed, uint8_t *buf)
{
    uint8_t asc[15];
    static uint32_t temp;
    float ws;

    temp = (pm25_dat > 999)? 999 : pm25_dat;

    asc[0] =  (temp /100);
    asc[1] =  (temp / 10 % 10);
    asc[2] =  (temp % 10);

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    if (asc[0] == 0 && asc[1] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[1] + 0x30;

    *buf++ = asc[2] + 0x30;

    *buf++ = 0x20;

    temp = (pm10_dat > 999)? 999 : pm10_dat;

    asc[0] =  (temp /100);
    asc[1] =  (temp /10 % 10);
    asc[2] =  (temp % 10);

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    if (asc[0] == 0 && asc[1] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[1] + 0x30;

    *buf++ = asc[2] + 0x30;

    ws = windspeed*10.0f;
    temp = (ws > 999)? 999 : ws;

    asc[0] =  (temp /100);
    asc[1] =  (temp /10 % 10);
    asc[2] =  (temp % 10);

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    *buf++ = asc[1] + 0x30;

    *buf++ = '.';

    *buf++ = asc[2] + 0x30;

    *buf = 0;
}


/* **************************************************
 fucntion:      APP_led_thnf2a
 input:
 output:
 describe:  translate temperatrue & humidity & noise value to ascii
***************************************************/

void APP_led_thnf2a(float v_temp, float v_humi, float noise, uint8_t *buf)
{
    uint8_t asc[15];
    static uint32_t temp;
    float tv,hv,ns;

    tv = v_temp*10.0f;
    // test limit -40~+80
    if (tv < -400) tv = -400;
    if (tv > 800) tv = 800;

    if (tv < 0)
    {
        temp = -tv;
    }
    else temp = tv;

    if (v_temp < 0) // 零下
    {
        asc[0] = '-';
        asc[1] = (temp / 100);
        asc[2] = (temp / 10 % 10);
        asc[3] = (temp % 10);
    }
    else    // 零上
    {
        asc[0] = 0;
        asc[1] = (temp / 100);
        asc[2] = (temp / 10 % 10);
        asc[3] = (temp % 10);
    }

    // 符号位
    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else if (asc[0] == '-')
    {
        *buf++ = '-';
    }
    else *buf++ = asc[0] + 0x30;

    // 最高位
    if (asc[1] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[1] + 0x30;

    // 次高位
    *buf++ = asc[2] + 0x30;

    // 小数点位
    *buf++ = '.';

    // 小数位
    *buf++ = asc[3] + 0x30;


    // 湿度
    hv = v_humi * 10.0f;
    // test limit 0~100
    if (hv < 0) hv = 0;
    if (hv > 999) hv = 999;

    temp = hv;

    asc[0] = (temp / 100);
    asc[1] = (temp / 10 % 10);
    asc[2] = (temp % 10);

    *buf++ = ' ';

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    *buf++ = asc[1] + 0x30;

    *buf++ = '.';

    *buf++ = asc[2] + 0x30;

    // 噪声
    ns = noise * 10.0f;
    // test limit 30~130
    if (ns < 300) ns = 300;
    if (ns > 1300) ns = 1300;
    temp = ns;

    asc[0] = (temp / 1000);
    asc[1] = (temp / 100 % 10);
    asc[2] = (temp / 10 % 10);
    asc[3] = (temp % 10);

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    if (asc[1] == 0 && asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[1] + 0x30;

    *buf++ = asc[2] + 0x30;

    *buf++ = '.';

    *buf++ = asc[3] + 0x30;

    *buf = 0;
}

/* **************************************************
 fucntion:      APP_led_vthnf2a
 input:
 output:
 describe:  translate vane & temperatrue & humidity & noise value to ascii
***************************************************/

void APP_led_vthnf2a(float v_vane, float v_temp, float v_humi, float noise, uint8_t *buf)
{
    uint8_t asc[15];
    static uint32_t temp;
    float tv,hv,ns;

    tv = v_vane;
    if ((v_vane >= 348.75f && v_vane < 360.0f) || (v_vane >= 0.0f && v_vane < 11.25f)) strcpy((char *)buf, "   北  ");
    else if (v_vane >= 11.25f && v_vane < 33.75f) strcpy((char *)buf, " 北东北");
    else if (v_vane >= 33.75f && v_vane < 56.25f) strcpy((char *)buf, "   东北");
    else if (v_vane >= 56.25f && v_vane < 78.75f) strcpy((char *)buf, " 东东北");
    else if (v_vane >=  78.75f && v_vane <101.25f) strcpy((char *)buf,"   东  ");
    else if (v_vane >= 101.25f && v_vane <123.75f) strcpy((char *)buf," 东东南");
    else if (v_vane >= 123.75f && v_vane <146.25f) strcpy((char *)buf,"   东南");
    else if (v_vane >= 146.25f && v_vane <168.75f) strcpy((char *)buf," 南东南");
    else if (v_vane >= 168.75f && v_vane <191.25f) strcpy((char *)buf,"   南  ");
    else if (v_vane >= 191.25f && v_vane <213.75f) strcpy((char *)buf," 南西南");
    else if (v_vane >= 213.75f && v_vane <236.25f) strcpy((char *)buf,"   西南");
    else if (v_vane >= 236.25f && v_vane <258.75f) strcpy((char *)buf," 西西南");
    else if (v_vane >= 258.75f && v_vane <281.25f) strcpy((char *)buf,"   西  ");
    else if (v_vane >= 281.25f && v_vane <303.75f) strcpy((char *)buf," 西西北");
    else if (v_vane >= 303.75f && v_vane <326.25f) strcpy((char *)buf,"   西北");
    else if (v_vane >= 326.25f && v_vane <348.75f) strcpy((char *)buf," 北西北");
    else strcpy((char *)buf, "       ");
    buf += 7;

    tv = v_temp * 10.0f;
    // test limit -40~+80
    if (tv < -400) tv = -400;
    if (tv > 800) tv = 800;

    if (tv < 0)
    {
        temp = -tv;
    }
    else temp = tv;

    if (v_temp < 0) // 零下
    {
        asc[0] = '-';
        asc[1] = (temp / 100);
        asc[2] = (temp / 10 % 10);
        asc[3] = (temp % 10);
    }
    else    // 零上
    {
        asc[0] = 0;
        asc[1] = (temp / 100);
        asc[2] = (temp / 10 % 10);
        asc[3] = (temp % 10);
    }

    // 符号位
    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else if (asc[0] == '-')
    {
        *buf++ = '-';
    }
    else *buf++ = asc[0] + 0x30;

    // 最高位
    if (asc[1] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[1] + 0x30;

    // 次高位
    *buf++ = asc[2] + 0x30;

    // 小数点位
    *buf++ = '.';

    // 小数位
    *buf++ = asc[3] + 0x30;
    // 单位
    strcpy((char *)buf, "℃");
    buf += 2;

    // 湿度
    hv = v_humi * 10.0f;
    // test limit 0~100
    if (hv < 0) hv = 0;
    if (hv > 999) hv = 999;

    temp = hv;

    asc[0] = (temp / 100);
    asc[1] = (temp / 10 % 10);
    asc[2] = (temp % 10);

    *buf++ = ' ';

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    *buf++ = asc[1] + 0x30;

    *buf++ = '.';

    *buf++ = asc[2] + 0x30;
    // 单位
    *buf++ = ' ';
    *buf++ = '%';

    // 噪声
    ns = noise * 10.0f;
    // test limit 30~130
    if (ns < 300) ns = 300;
    if (ns > 1300) ns = 1300;
    temp = ns;

    asc[0] = (temp / 1000);
    asc[1] = (temp / 100 % 10);
    asc[2] = (temp / 10 % 10);
    asc[3] = (temp % 10);

    if (asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[0] + 0x30;

    if (asc[1] == 0 && asc[0] == 0)
    {
        *buf++ = 0x20;
    }
    else *buf++ = asc[1] + 0x30;

    *buf++ = asc[2] + 0x30;

    *buf++ = '.';

    *buf++ = asc[3] + 0x30;
    // 单位
    *buf++ = 'd';
    *buf++ = 'B';

    *buf = 0;
}
#ifdef LED_DEBUG
    #define _STATIC static
#else
    #define _STATIC
#endif

/* ***************************   functions  **********************************/

#undef _STATIC


#undef  _LOCAL_LED

/* ****************************  END OF FILE  *********************************/

