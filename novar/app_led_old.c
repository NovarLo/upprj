



#define	_LOCAL_LED

#include "stm32f4xx_hal.h"
#include "arm_math.h"
#include "string.h"
#include "app_user.h"
#include "app_sensor.h"
#include "app_mmi.h"
#include "app_led.h"

// SRT_PM  PM2.5&PM10  384bytes(96*32/8) 
/* *****************
*   PM2.5:    ug  *
*   PM1 0:    ug  *
******************/ 
const uint8_t SRT_PM[] = {
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : PM2.5:    ug
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/9/29 10:03:47
------------------------------------------------------------------------------*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x77,0x3C,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x42,0x36,0x42,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x36,0x42,0x00,
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x36,0x42,0x00,0x02,0x18,0x00,0x00,
0x00,0x00,0x00,0x00,0x42,0x36,0x20,0x00,0x1A,0x18,0x00,0x00,0x00,0x00,0x63,0x7C,
0x3E,0x2A,0x20,0x00,0x26,0x00,0x00,0x00,0x00,0x00,0x42,0x22,0x02,0x2A,0x10,0x00,
0x40,0x00,0x00,0x00,0x00,0x00,0x42,0x22,0x02,0x2A,0x08,0x00,0x40,0x00,0x00,0x00,
0x00,0x00,0x42,0x1C,0x02,0x2A,0x04,0x00,0x42,0x00,0x00,0x00,0x00,0x00,0x42,0x02,
0x02,0x2A,0x42,0x06,0x22,0x18,0x00,0x00,0x00,0x00,0x62,0x3C,0x07,0x6B,0x7E,0x06,
0x1C,0x18,0x00,0x00,0x00,0x00,0xDC,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : PM10 :    ug
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/9/29 10:05:00
------------------------------------------------------------------------------*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x77,0x08,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x42,0x36,0x0E,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x36,0x08,0x42,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x36,0x08,0x42,0x00,0x18,0x00,0x00,
0x00,0x00,0x00,0x00,0x42,0x36,0x08,0x42,0x00,0x18,0x00,0x00,0x00,0x00,0x63,0x7C,
0x3E,0x2A,0x08,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x22,0x02,0x2A,0x08,0x42,
0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x22,0x02,0x2A,0x08,0x42,0x00,0x00,0x00,0x00,
0x00,0x00,0x42,0x1C,0x02,0x2A,0x08,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x02,
0x02,0x2A,0x08,0x24,0x00,0x18,0x00,0x00,0x00,0x00,0x62,0x3C,0x07,0x6B,0x3E,0x18,
0x00,0x18,0x00,0x00,0x00,0x00,0xDC,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C
};

// SRT_TH Temperature&Humidity 384Bytes(96*32/8)
/* *****************
*   温 度:    ℃  *
*   湿 度:    ％  *
******************/ 
const uint8_t SRT_TH[] = {
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 温度:     ℃
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/9/29 10:23:16
------------------------------------------------------------------------------*/
0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0xC4,0x1F,0x00,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x89,0x2F,0x48,0x10,0xFC,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x69,0x30,0x48,0x10,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x36,0x20,
0xC1,0x1F,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x20,0x42,0x10,0xFC,0x3F,
0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x42,0x10,0x44,0x04,0x18,0x00,0x00,0x00,
0x00,0x00,0x18,0x00,0xC8,0x1F,0x44,0x04,0x18,0x00,0x00,0x00,0x00,0x00,0x18,0x00,
0x08,0x00,0xC4,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0xE4,0x3F,0x04,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x27,0x25,0xF4,0x0F,0x00,0x00,0x00,0x00,
0x00,0x00,0x18,0x00,0x24,0x25,0x24,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,
0x24,0x25,0x42,0x04,0x18,0x00,0x00,0x00,0x00,0x00,0x30,0x20,0x24,0x25,0x82,0x03,
0x18,0x00,0x00,0x00,0x00,0x00,0x60,0x10,0xF4,0x7F,0x61,0x0C,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x0F,0x00,0x00,0x1C,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 湿度:	     ％
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/9/29 10:26:13
------------------------------------------------------------------------------*/
0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE4,0x1F,0x00,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x20,0x28,0x10,0xFC,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x24,0x10,0x28,0x10,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x08,
0xE1,0x1F,0x44,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x04,0x22,0x10,0xFC,0x3F,
0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x02,0x22,0x10,0x44,0x04,0x18,0x00,0x00,0x00,
0x00,0x00,0x24,0x01,0xE8,0x1F,0x44,0x04,0x18,0x00,0x00,0x00,0x00,0x00,0x98,0x00,
0x88,0x04,0xC4,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x06,0x84,0x04,0x04,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x09,0x97,0x24,0xF4,0x0F,0x00,0x00,0x00,0x00,
0x00,0x00,0x10,0x09,0xA4,0x14,0x24,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x09,
0xC4,0x0C,0x42,0x04,0x18,0x00,0x00,0x00,0x00,0x00,0x04,0x09,0x84,0x04,0x82,0x03,
0x18,0x00,0x00,0x00,0x00,0x00,0x02,0x09,0xF4,0x7F,0x61,0x0C,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x06,0x00,0x00,0x1C,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

// STR_WS wind speed & company name 384Bytes(96*32/8)
/* *****************
*   风 速: -.-m/s *
*   噪 声: ---.-dB*
******************/ 
const uint8_t SRT_WIND_NOISE[] = {
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 风速:    m/s
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/9/29 10:27:53
------------------------------------------------------------------------------*/
0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x0F,0x04,0x02,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x08,0xE8,0x3F,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x00,0x04,0x08,0x08,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,
0x14,0x0A,0xC0,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x24,0x0A,0x40,0x12,
0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x44,0x09,0x4F,0x12,0x18,0x00,0x00,0x00,
0x00,0x00,0x20,0x00,0x44,0x09,0xC8,0x1F,0x18,0x00,0x00,0x00,0x00,0x7F,0x10,0x7C,
0x84,0x08,0x08,0x07,0x00,0x00,0x00,0x00,0x00,0x92,0x10,0x42,0x84,0x08,0x88,0x0A,
0x00,0x00,0x00,0x00,0x00,0x92,0x08,0x02,0x44,0x09,0x48,0x12,0x00,0x00,0x00,0x00,
0x00,0x92,0x08,0x3C,0x44,0x49,0x28,0x22,0x00,0x00,0x00,0x00,0x00,0x92,0x04,0x40,
0x24,0x52,0x08,0x02,0x18,0x00,0x00,0x00,0x00,0x92,0x04,0x42,0x12,0x52,0x14,0x00,
0x18,0x00,0x00,0x00,0x00,0xB7,0x02,0x3E,0x02,0x60,0xE2,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x02,0x00,0x01,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 噪声:     dB
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/9/29 10:29:11
------------------------------------------------------------------------------*/
0xC0,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x10,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4F,0x10,0xFF,0x7F,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xC9,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x1F,
0x09,0x00,0xFE,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x22,0xE9,0x3D,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x22,0x29,0x25,0xFC,0x1F,0x18,0x00,0x00,0x00,
0x00,0x00,0x40,0x22,0x29,0x25,0x84,0x10,0x18,0x00,0x00,0x00,0x00,0x00,0x78,0x1E,
0xE9,0x3D,0x84,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x22,0x09,0x02,0xFC,0x1F,
0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0xFF,0x7F,0x04,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x42,0x42,0x89,0x06,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,
0x40,0x0A,0x04,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x64,0x22,0x20,0x12,0x02,0x00,
0x18,0x00,0x00,0x00,0x00,0x00,0xD8,0x1F,0x18,0x62,0x02,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

/* *****************
*   风 速: -.-m/s *
*   陕西泰新博坤  *
******************/ 
const uint8_t SRT_WIND[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x10,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xFC,0x83,0xFE,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,
0x04,0x02,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x84,0x02,0xFE,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x8C,0xC2,0x92,0x60,0x00,0x00,0x00,0x00,
0x00,0x00,0x10,0x00,0x54,0x82,0x92,0x60,0x00,0x00,0x00,0x00,0x00,0x7C,0x10,0x3C,
0x24,0x82,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0xA8,0x08,0x22,0x24,0x82,0x38,0x00,
0x00,0x00,0x00,0x00,0x00,0xA8,0x08,0x0C,0x54,0x8A,0x54,0x60,0x00,0x00,0x00,0x00,
0x00,0xA8,0x04,0x10,0x8C,0x8A,0x92,0x60,0x00,0x00,0x00,0x00,0x00,0xA8,0x04,0x22,
0x04,0x8C,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0xAC,0x03,0x1E,0x02,0x48,0xFF,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 扬尘在线监控
;  宽×高（像素）: 96×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/192字节
;  数据转换日期  : 2016/11/21 10:14:23
------------------------------------------------------------------------------*/
0x08,0x00,0x80,0x00,0x40,0x00,0x08,0x0A,0x20,0x02,0x08,0x02,0x88,0x1F,0x80,0x00,
0x40,0x00,0x08,0x12,0x24,0x02,0x08,0x04,0x08,0x08,0x90,0x04,0x20,0x00,0x04,0x02,
0x24,0x3E,0x08,0x04,0x08,0x04,0x90,0x08,0xFF,0x7F,0x24,0x3A,0x24,0x02,0xC8,0x7F,
0x3F,0x02,0x88,0x10,0x10,0x00,0xA2,0x07,0x24,0x09,0x5F,0x40,0x08,0x01,0x84,0x20,
0x10,0x02,0x1F,0x02,0x24,0x11,0x28,0x29,0x88,0x7F,0x82,0x20,0x08,0x02,0x08,0x7A,
0xA4,0x10,0x88,0x10,0x28,0x49,0x00,0x00,0x0C,0x02,0xC4,0x07,0x20,0x00,0x58,0x20,
0x18,0x49,0x80,0x00,0xEA,0x3F,0x02,0x22,0x00,0x00,0x0C,0x00,0x0C,0x49,0x80,0x00,
0x09,0x02,0x3F,0x12,0xFC,0x1F,0x8B,0x3F,0x8B,0x48,0xFC,0x1F,0x08,0x02,0x02,0x0C,
0x24,0x12,0x08,0x04,0x88,0x44,0x80,0x00,0x08,0x02,0x00,0x44,0x24,0x12,0x08,0x04,
0x48,0x44,0x80,0x00,0x08,0x02,0x38,0x4A,0x24,0x12,0x08,0x04,0x28,0x42,0x80,0x00,
0x08,0x02,0x07,0x51,0x24,0x12,0x08,0x04,0x0A,0x29,0xFF,0x7F,0xF8,0x7F,0xC2,0x60,
0xFF,0x7F,0xEA,0x7F,0x84,0x10,0x00,0x00,0x08,0x00,0x00,0x40,0x00,0x00,0x04,0x00
/*  泰新博坤 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x40,0x20,0x82,0x42,
0x10,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xF0,0x1D,0xF2,0x47,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,0x00,0x04,0x82,0x40,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,
0x10,0x05,0xF2,0x47,0x92,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xA0,0x3C,0x97,0xE4,
0x92,0x00,0x00,0x00,0x00,0x00,0xC0,0xFF,0xF9,0x15,0xF2,0x47,0xFE,0x00,0x00,0x00,
0x00,0x00,0x00,0x49,0x40,0x14,0x92,0x44,0x92,0x00,0x00,0x00,0x00,0x00,0x80,0x88,
0xF0,0x15,0x92,0x44,0x92,0x00,0x00,0x00,0x00,0x00,0x40,0x5D,0x41,0x14,0x02,0x42,
0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x2A,0x50,0x15,0xF2,0xC7,0x92,0x00,0x00,0x00,
0x00,0x00,0x00,0x49,0x48,0x12,0x22,0x62,0x10,0x00,0x00,0x00,0x00,0x00,0xC0,0x8C,
0x61,0x11,0x42,0x03,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00*/

/*  荣炜科技 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x20,0x04,0x08,0x81,
0x10,0x00,0x00,0x00,0x00,0x00,0xC0,0xFF,0x21,0x04,0x27,0x81,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x22,0xA0,0x3F,0x44,0x81,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x68,0x04,0x04,0xE1,0x11,0x00,0x00,0x00,0x00,0x00,0xC0,0xFF,0x29,0x1F,0x3F,0x81,
0x10,0x00,0x00,0x00,0x00,0x00,0x40,0x08,0x29,0x04,0x44,0x81,0x7E,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,0xA8,0x3F,0x0E,0x81,0x45,0x00,0x00,0x00,0x00,0x00,0xC0,0xFF,
0x21,0x24,0x16,0xE7,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x2A,0x20,0x24,0xE5,0x81,
0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x49,0x50,0x34,0x04,0x81,0x10,0x00,0x00,0x00,
0x00,0x00,0xC0,0x88,0x91,0x04,0x04,0x81,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x08,
0x08,0x04,0x04,0xC1,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00*/ 
	/*  渝仁蓉达 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x10,0x40,0x00,0x88,0x40,
0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x40,0x00,0xFF,0x87,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x44,0x20,0x00,0xA8,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0xBA,
0xA1,0x1F,0xFF,0x07,0xFE,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x30,0x00,0x89,0xE4,
0x10,0x00,0x00,0x00,0x00,0x00,0x80,0x1E,0x29,0x00,0x24,0x81,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x52,0x21,0x00,0x50,0x80,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x5E,
0x21,0x00,0x8C,0x81,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x53,0x21,0x00,0x03,0x86,
0x84,0x00,0x00,0x00,0x00,0x00,0x80,0x5E,0x21,0x00,0xFC,0x81,0x82,0x00,0x00,0x00,
0x00,0x00,0x40,0x12,0xE1,0x3F,0x04,0x41,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x9A,
0x21,0x00,0xFC,0x21,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00*/
 /*  中桴美达
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x20,0x38,0x04,0x41,
0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xA0,0x07,0x88,0x80,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,0x20,0x22,0xFE,0x03,0x10,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,
0xF8,0x14,0x20,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x80,0x88,0x20,0x01,0xFE,0xE3,
0x10,0x00,0x00,0x00,0x00,0x00,0x80,0x88,0xB0,0x1F,0x20,0x80,0x10,0x00,0x00,0x00,
0x00,0x00,0x80,0x88,0x70,0x08,0xFF,0x87,0x28,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,
0x28,0x04,0x20,0x80,0x48,0x00,0x00,0x00,0x00,0x00,0x80,0x88,0xA0,0x3F,0xFF,0x87,
0x84,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x20,0x04,0x50,0x80,0x82,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,0x20,0x04,0x8C,0x41,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x08,
0x20,0x06,0x03,0x26,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00*/
};
/* *****************
*   
*   陕西泰新博坤  *
******************/ 
const uint8_t SRT_MFR[] = {
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 泰新博坤
;  宽×高（像素）: 96×32
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/384字节
;  数据转换日期  : 2016/9/30 11:06:36
------------------------------------------------------------------------------
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x40,0x00,0x10,0x30,0xC0,
0x06,0x60,0x80,0x01,0x00,0x0C,0x08,0x80,0x00,0x3C,0x10,0x40,0x0C,0x20,0x80,0x00,
0xF8,0xFF,0x1F,0x80,0xCC,0x03,0x10,0x40,0x34,0x20,0x80,0x00,0x00,0x04,0x00,0x7C,
0x43,0x00,0x10,0xFF,0x0B,0x20,0x80,0x00,0x00,0x04,0x00,0x10,0x46,0x00,0x10,0x40,
0x08,0x20,0x88,0x10,0xF0,0xFF,0x07,0x20,0x42,0x00,0x10,0xFE,0x1F,0x20,0xF8,0x1F,
0x00,0x06,0x00,0x20,0x41,0x00,0xFE,0x42,0x08,0xFE,0x8B,0x10,0x00,0x02,0x10,0x20,
0x59,0x30,0x10,0x43,0x08,0x20,0x88,0x10,0xFE,0xFF,0x3F,0xFC,0xFF,0x7F,0x10,0xFE,
0x0F,0x20,0x88,0x10,0x00,0x41,0x00,0x80,0x40,0x0C,0x10,0x42,0x08,0x20,0xF8,0x1F,
0x80,0x81,0x00,0x80,0x40,0x0C,0x10,0x42,0x08,0x20,0x88,0x10,0x80,0x08,0x01,0x80,
0x48,0x0C,0x10,0xFE,0x0F,0x20,0x88,0x10,0x40,0x08,0x03,0xF8,0x47,0x0C,0x10,0x42,
0x04,0x20,0x88,0x10,0xA0,0x88,0x06,0x80,0x40,0x0C,0x10,0x01,0x24,0x20,0xF9,0x1F,
0x10,0x6B,0x1D,0xB0,0x42,0x0C,0xD0,0xFF,0x7F,0xE0,0x88,0x10,0x08,0x19,0x30,0x98,
0x6C,0x0C,0x10,0x02,0x04,0x1E,0x80,0x00,0x06,0x0A,0x00,0x88,0x28,0x0C,0x10,0x04,
0x04,0x04,0x80,0x00,0x80,0xC9,0x00,0x84,0x28,0x0C,0x10,0x08,0x04,0x00,0x80,0x00,
0x70,0x88,0x03,0x84,0x10,0x0C,0x10,0x08,0x04,0x00,0x80,0x00,0x30,0x0F,0x03,0xE2,
0x08,0x0C,0x10,0x80,0x07,0x00,0x80,0x00,0x00,0x0C,0x00,0x40,0x04,0x0C,0x10,0x00,
0x06,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00*/
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 荣炜科技
;  宽×高（像素）: 96×32
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/384字节
;  数据转换日期  : 2016/9/30 11:03:30
------------------------------------------------------------------------------*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0xC3,0x00,0x60,0x80,0x01,0x00,0x02,
0x0C,0xE0,0x80,0x01,0x00,0xC3,0x00,0x60,0x80,0x00,0xC0,0x07,0x04,0x60,0x80,0x00,
0x00,0xC3,0x18,0x60,0x80,0x10,0xFC,0x00,0x04,0x60,0x80,0x00,0xFC,0xFF,0x3F,0x60,
0xFC,0x3F,0xC0,0x20,0x04,0x60,0x80,0x00,0x00,0xC3,0x00,0x60,0x82,0x00,0xC0,0xC0,
0x04,0x60,0x83,0x30,0x00,0x41,0x00,0x60,0x83,0x00,0xC0,0xC0,0x04,0xFC,0xFC,0x0F,
0x00,0x00,0x10,0xE0,0x80,0x08,0xC0,0x06,0x04,0x60,0x80,0x00,0xF0,0xFF,0x3F,0x64,
0xF8,0x1F,0xFC,0x01,0x04,0x60,0x80,0x00,0x18,0x18,0x08,0x6C,0x80,0x00,0xC0,0x10,
0x04,0x60,0x80,0x00,0x0C,0x18,0x04,0x64,0x80,0x00,0xE0,0x60,0x04,0x60,0xFF,0x1F,
0x00,0x18,0x18,0x60,0x80,0x20,0xE0,0x43,0x04,0xE0,0x10,0x08,0xF8,0xFF,0x3F,0x20,
0xFC,0x3F,0xF0,0x46,0x24,0x7C,0x10,0x0C,0x00,0x3E,0x00,0x20,0x80,0x30,0xD0,0x04,
0x74,0x64,0x20,0x04,0x00,0x5A,0x00,0x20,0x80,0x30,0xC8,0x80,0x0F,0x60,0x20,0x06,
0x00,0x99,0x00,0xE0,0x80,0x30,0xC8,0x7C,0x04,0x60,0x40,0x02,0x80,0x18,0x01,0x30,
0x81,0x10,0xC4,0x00,0x04,0x60,0x40,0x03,0x40,0x18,0x06,0x10,0x83,0x10,0xC2,0x00,
0x04,0x60,0x80,0x01,0x30,0x18,0x7C,0x10,0x82,0x1C,0xC0,0x00,0x04,0x60,0xC0,0x01,
0x08,0x18,0x18,0x08,0x80,0x08,0xC0,0x00,0x04,0x60,0x30,0x06,0x04,0x18,0x00,0x04,
0x80,0x00,0xC0,0x00,0x04,0x78,0x08,0x7C,0x00,0x18,0x00,0x04,0x80,0x00,0xC0,0x00,
0x04,0x30,0x07,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 渝仁蓉达
;  宽×高（像素）: 96×32
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/384字节
;  数据转换日期  : 2016/9/30 11:07:26
------------------------------------------------------------------------------
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x60,0x00,0x80,0x01,0x00,0x00,0x83,
0x00,0x10,0xC0,0x00,0x30,0xA0,0x00,0xC0,0x00,0x00,0x00,0x81,0x10,0x20,0x40,0x00,
0x20,0x30,0x01,0xC0,0x00,0x00,0xFC,0xFF,0x3F,0x60,0x40,0x00,0x20,0x18,0x03,0x40,
0x00,0x08,0x00,0x89,0x00,0x60,0x40,0x00,0x80,0x08,0x06,0x60,0xFC,0x1F,0x00,0x99,
0x00,0x00,0x40,0x00,0x80,0x04,0x1D,0x20,0x00,0x00,0x00,0x10,0x10,0x00,0x40,0x30,
0x46,0xFA,0x7B,0xE0,0x00,0x00,0xF0,0xFF,0x3F,0x00,0xFF,0x7F,0x4C,0x01,0x14,0x70,
0x00,0x00,0x18,0x01,0x18,0x20,0x40,0x00,0xC8,0x21,0x10,0x70,0x00,0x00,0x88,0x9B,
0x05,0x3C,0x60,0x00,0x20,0x3F,0x11,0x68,0x00,0x00,0xC0,0x18,0x07,0x20,0x60,0x00,
0x20,0x21,0x13,0x64,0x00,0x00,0x60,0x1C,0x06,0x20,0x60,0x00,0x20,0x21,0x11,0x62,
0x00,0x00,0x10,0x26,0x04,0x20,0xB0,0x01,0x10,0x3F,0x11,0x62,0x00,0x00,0x00,0xC3,
0x00,0x20,0x10,0x02,0x10,0x21,0x11,0x60,0x00,0x00,0x80,0x81,0x01,0x20,0x08,0x0C,
0x1E,0x21,0x11,0x60,0x00,0x00,0xC0,0xFF,0x0F,0x20,0x04,0x08,0x18,0x3F,0x11,0x60,
0x00,0x00,0xB0,0x01,0x3D,0x20,0x02,0x18,0x08,0x21,0x11,0x60,0x00,0x00,0x8C,0x01,
0x11,0xB0,0x01,0x00,0x08,0x21,0x13,0x60,0x00,0x30,0x80,0x01,0x01,0xCC,0x00,0x00,
0x08,0x21,0x10,0x60,0xFE,0x0F,0x80,0x01,0x01,0x06,0x03,0x00,0x08,0x3D,0x1E,0x60,
0x00,0x00,0x80,0xFF,0x01,0x00,0xFE,0x3F,0x00,0x11,0x18,0x60,0x00,0x00,0x80,0x01,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00*/ 
/* ------------------------------------------------------------------------------
;  若数据乱码，请检查字模格式设置，注意选择正确的取模方向和字节位顺序。
;  源文件 / 文字 : 中桴美达
;  宽×高（像素）: 96×32
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节倒序/384字节
;  数据转换日期  : 2016/9/30 11:07:59
------------------------------------------------------------------------------
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x60,0x00,0x18,0x80,0xC1,
0x01,0x10,0xC0,0x00,0x00,0x08,0x00,0x20,0xC0,0x3F,0x00,0x43,0x00,0x20,0x40,0x00,
0x00,0x08,0x00,0x20,0x3E,0x10,0x00,0x23,0x08,0x60,0x40,0x00,0x00,0x08,0x00,0x20,
0x44,0x30,0xF8,0xFF,0x1F,0x60,0x40,0x00,0x08,0x08,0x18,0x20,0x89,0x18,0x00,0x08,
0x00,0x00,0x40,0x00,0xF8,0xFF,0x1F,0xFE,0x9B,0x09,0x00,0x08,0x00,0x00,0x40,0x30,
0x18,0x08,0x18,0x20,0x98,0x05,0x00,0x08,0x06,0x00,0xFF,0x7F,0x18,0x08,0x18,0x20,
0x00,0x0A,0xE0,0xFF,0x01,0x20,0x40,0x00,0x18,0x08,0x18,0xF0,0xFC,0x1F,0x00,0x08,
0x00,0x3C,0x60,0x00,0x18,0x08,0x18,0xB0,0x01,0x04,0x00,0x08,0x30,0x20,0x60,0x00,
0x18,0x08,0x18,0x30,0x01,0x03,0xFC,0xF7,0x0F,0x20,0x60,0x00,0x18,0x08,0x18,0x28,
0x81,0x01,0x00,0x18,0x00,0x20,0xB0,0x01,0xF8,0xFF,0x1F,0x28,0x80,0x20,0x00,0x08,
0x08,0x20,0x10,0x02,0x08,0x08,0x08,0x24,0xFE,0x7F,0xFC,0xFF,0x1F,0x20,0x08,0x0C,
0x00,0x08,0x00,0x24,0x80,0x00,0x00,0x1C,0x00,0x20,0x04,0x08,0x00,0x08,0x00,0x22,
0x80,0x00,0x00,0x24,0x00,0x20,0x02,0x18,0x00,0x08,0x00,0x20,0x80,0x00,0x00,0x46,
0x00,0xB0,0x01,0x00,0x00,0x08,0x00,0x20,0x80,0x00,0x00,0x83,0x00,0xCC,0x00,0x00,
0x00,0x18,0x00,0x20,0x80,0x00,0x80,0x01,0x07,0x06,0x03,0x00,0x00,0x18,0x00,0x20,
0xF0,0x00,0x40,0x00,0x7E,0x00,0xFE,0x3F,0x00,0x18,0x00,0x20,0xC0,0x00,0x3C,0x00,
0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00*/
};
/* *********************  local variable & macro  ****************************/

uint16_t get_chksum16(uint8_t *data,uint16_t num)
{
	uint16_t i,sum = 0; 

    for (i=0;i<num;i++)
    {
        sum += data[i];
    }

    return sum&0xffff;
}

/* **************************************************
 fucntion:		APP_led_reciveisr
 input:		byte: data received form uart6
 output:
 describe:	uart receive isr of LED
***************************************************/
void APP_led_rcvisr(void)
{
	 enum
	{
		LED_RCVSTEP_IDLE = 0,
		LED_RCVSTEP_SYN1,	// 0xAA
		LED_RCVSTEP_SYN2,	// 0x55
		LED_RCVSTEP_ADDR1,	// 0xFF
		LED_RCVSTEP_ADDR2,	// 0xFF
		LED_RCVSTEP_LEN1,	// low byte
		LED_RCVSTEP_LEN2,	// high byte
		LED_RCVSTEP_DAT,	

		LED_RCVSTEP_MAX
	 };
	static uint8_t led_rcvstep = LED_RCVSTEP_IDLE;
	static uint8_t frame_len = 0;
	
	uint32_t tick;
	//uint32_t index;
	uint8_t byte = led_rcvbyte;
	uint16_t chksum;
		
	HAL_UART_Receive_IT(HDL_UART_LED, &led_rcvbyte, 1);

	tick = HAL_GetTick();
	if ((tick - led_rcvbuf.timestamp) > 200)
	{
		led_rcvstep = LED_RCVSTEP_IDLE;
		led_rcvbuf.rcvindex = 0;
	}
	led_rcvbuf.timestamp = tick;

	switch (led_rcvstep)
	{
		case LED_RCVSTEP_IDLE:
			led_rcvbuf.rcvindex = 0;
			if (byte == (EX30_SYN & 0xFF))
			{		// find start byte(low)
				led_rcvstep = LED_RCVSTEP_SYN1;
				led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
			}
			break;
		case LED_RCVSTEP_SYN1:
			if (byte == ((EX30_SYN >> 8) & 0xFF))
			{		// find start byte(high)
				led_rcvstep = LED_RCVSTEP_SYN2;
				led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
			}
		break;
		case LED_RCVSTEP_SYN2:
		   if (byte == (EX30_ADDR & 0x00FF))
		   {		// find address byte(low)
			   led_rcvstep = LED_RCVSTEP_ADDR1;
			   led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
		   }
		break;
		case LED_RCVSTEP_ADDR1:
			if (byte == (EX30_ADDR >> 8 & 0xFF))
		   {		// find address byte(high)
			   led_rcvstep = LED_RCVSTEP_ADDR2;
			   led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
		   }
		break;
		case LED_RCVSTEP_ADDR2:
			led_rcvbuf.len = byte;
			led_rcvstep = LED_RCVSTEP_LEN1;
			led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
		break;
		case LED_RCVSTEP_LEN1:
			led_rcvbuf.len += byte<<8;
			frame_len = led_rcvbuf.len;
			led_rcvstep = LED_RCVSTEP_LEN2;
			led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
		break;
		case LED_RCVSTEP_LEN2:
			if (led_rcvbuf.rcvindex >= LED_RCVBUFSIZE)
			{
				led_rcvstep = LED_RCVSTEP_IDLE;
				led_rcvbuf.rcvindex = 0;
			}
			else	// 接收dat信息(serial+type+cmd+tlv)
			{
				led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex++] = byte;
				if (led_rcvbuf.rcvindex == frame_len + 6)	// full frame is received
				{
					led_rcvbuf.serial = led_rcvbuf.rcvbyte[6] + (led_rcvbuf.rcvbyte[7]<<8); 
					led_rcvbuf.type = led_rcvbuf.rcvbyte[8];
					led_rcvbuf.cmd = led_rcvbuf.rcvbyte[9];
					led_rcvbuf.tlv[0] = led_rcvbuf.rcvbyte[10];	// 写应答，返回错误码;
																// 读应答，返回tag/设备信息（0x18）
					if (led_rcvbuf.cmd == EX30_ACK_RD) 
					{
						led_rcvbuf.tlv[1] = led_rcvbuf.rcvbyte[11];		// 保存设备信息长度
						for (uint8_t i = 0; i < led_rcvbuf.rcvbyte[11]; i++)	// 保存设备信息
						{
							led_rcvbuf.tlv[2 + i] = led_rcvbuf.rcvbyte[12 + i];
						}
					}

					led_rcvbuf.chksum = led_rcvbuf.rcvbyte[(led_rcvbuf.rcvindex - 2)] + ((led_rcvbuf.rcvbyte[led_rcvbuf.rcvindex - 1]) << 8);
					chksum = get_chksum16(led_rcvbuf.rcvbyte, frame_len + 4);
					frame_len = 0;
					if (chksum == led_rcvbuf.chksum) 
					{
						led_rcvbuf.valid = TRUE; 
						led_sendbuf.busy = FALSE;
					}
					led_rcvstep = LED_RCVSTEP_IDLE;
					led_rcvbuf.rcvindex = 0;
				}
			}
		break;
			
		default :
			led_rcvstep = LED_RCVSTEP_IDLE;
			led_rcvbuf.rcvindex = 0;
			break;
			
	}
}

/* **************************************************
 fucntion:		APP_led_full
 input:
 output:
 describe:	send full frame
***************************************************/
void APP_led_full(APP_EX30_TypeDef *tlv)
{
	uint8_t* buf = led_sendbuf.dat;
	uint16_t chksum;
	//uint32_t length;

	// ------------ start of update ---------------

	FILL_HEAD(&buf);
	FILL_LEN(&buf, tlv->len);   // connect frame length
	FILL_SERIAL(&buf, tlv->serial); // serial number
	FILL_TYPE(&buf, tlv->type); 
	FILL_CMD(&buf, tlv->cmd); 
	for (uint8_t i = 0; i < tlv->tlvnum;i++)
	{
		// tag
		FILL_1B(&buf, tlv->tlv_buf[i].tag); 

		// tag length
		if (tlv->tlv_buf[i].len < 0x80)   // 1Byte
		{
			FILL_1B(&buf, tlv->tlv_buf[i].len & 0xff); 
		}
		else if (tlv->tlv_buf[i].len < 0xff && tlv->tlv_buf[i].len >= 0x80)// 2Byte
		{
			FILL_1B(&buf, 0x81);
			FILL_1B(&buf, tlv->tlv_buf[i].len & 0xFF);
		}
		else	// 3Byte
		{
			FILL_1B(&buf, 0x82);
			FILL_2B(&buf, tlv->tlv_buf[i].len); 
		}
		// tag value
		for (uint16_t j = 0; j < tlv->tlv_buf[i].len; j++)
		{
			FILL_1B(&buf, tlv->tlv_buf[i].value[j]); 
		}
	}
	chksum = get_chksum16(led_sendbuf.dat, (buf - led_sendbuf.dat));
	FILL_CHKSUM(&buf, chksum); 
	

	// set ready flag to send.				
	led_sendbuf.length = buf - led_sendbuf.dat;
	led_sendbuf.valid = TRUE;
	led_sendbuf.busy = TRUE;
	
	HAL_UART_Transmit_IT(HDL_UART_LED, led_sendbuf.dat, led_sendbuf.length);
}

/* **************************************************
 fucntion:		APP_led_display
 input:
 output:
 describe:	output routine of LED
***************************************************/

void APP_led_display(void)
{
	//uint8_t str[20];

	//	update pm2.5&pm10 txt
	APP_led_pmtxt();
	//	update temperature & humidity txt
	APP_led_thtxt();
	//	update wind speed txt
	APP_led_wntxt();
}


/* **************************************************
 fucntion:		APP_led_ini	
 input:
 output:
 describe:	LED initial
***************************************************/

void APP_led_ini(void)
{
 	HAL_UART_Receive_IT(HDL_UART_LED, &led_rcvbyte, 1);

	led_stat.update = TRUE;
	led_stat.packnum = 0;
	led_sendbuf.valid = FALSE;
	led_sendbuf.busy = FALSE;
	
/* 
    //APP_led_scrlogo();                               
    // communication handle                            
    APP_led_connect();                                 
    HAL_Delay(1000);                                   
                                                       
    // display pm2.5&pm10 subtitle screen              
    APP_led_pmdel();                                   
    HAL_Delay(1000);                                   
    APP_led_pmopt();                                   
    HAL_Delay(1000);                                   
    APP_led_pmsrt();                                   
    HAL_Delay(1000);                                   
    APP_led_pmtxt();                                   
    HAL_Delay(1000);                                   
                                                       
    // display temperature&humidity subtitle screen    
    APP_led_thdel();                                   
    HAL_Delay(1000);                                   
    APP_led_thopt();                                   
    HAL_Delay(1000);                                   
    APP_led_thsrt();                                   
    HAL_Delay(1000);                                   
    APP_led_thtxt();                                   
    HAL_Delay(1000);                                   
                                                       
    // display windspeed & company name subtitle screen
    APP_led_wndel();                                   
    HAL_Delay(1000);                                   
    APP_led_wnopt();                                   
    HAL_Delay(1000);                                   
    APP_led_wnsrt();                                   
    HAL_Delay(1000);                                   
    APP_led_wntxt();                                   
    HAL_Delay(1000);                                   
*/
}


/* **************************************************
 fucntion:		APP_led_logo	
 input:
 output:
 describe:	show logo screen
***************************************************/

void APP_led_logo(void)
{
	uint8_t* buf = led_sendbuf.dat;

	// set ready flag to send.				
	led_sendbuf.length = buf - led_sendbuf.dat;
	led_sendbuf.valid = TRUE;
	
	HAL_UART_Transmit(HDL_UART_LED, led_sendbuf.dat, led_sendbuf.length, 50);
	led_sendbuf.valid = FALSE;
}


/* **************************************************
 fucntion:		APP_led_connect
 input:
 output:
 describe:	connect ex-30 control card
***************************************************/

void APP_led_connect(void)
{
	APP_EX30_TypeDef ptlv;
	//uint8_t* buf = led_sendbuf.dat;
	//uint32_t length;

	// ------------ start of update ---------------
	ptlv.len = 0x0009;
	ptlv.serial = led_stat.packnum++;
	ptlv.type = EX30_TYPE;
	ptlv.cmd = EX30_CMD_RD;
	ptlv.tlvnum = 1;
	ptlv.tlv_buf[0].tag = EX30_TAG_DEVINFO; 
	ptlv.tlv_buf[0].len = 0x01;
	ptlv.tlv_buf[0].value[0] = 0x00;	// default
	APP_led_full(&ptlv);

/* 
    // set ready flag to send.                                              
    led_sendbuf.length = buf - led_sendbuf.dat;                             
    led_sendbuf.valid = TRUE;                                               
                                                                            
    HAL_UART_Transmit_IT(HDL_UART_LED, led_sendbuf.dat, led_sendbuf.length);
*/
}

/* **************************************************
 fucntion:		APP_led_setsrccfg
 input:
 output:
 describe:	set led screen parameters
***************************************************/

void APP_led_setsrccfg(void)
{
	APP_EX30_TypeDef ptlv;
	//uint8_t* buf = led_sendbuf.dat;
	//uint32_t length;

	// ------------ start of update ---------------
	ptlv.len = 0x0010;
	ptlv.serial = led_stat.packnum++;
	ptlv.type = EX30_TYPE;
	ptlv.cmd = EX30_CMD_WR;
	ptlv.tlvnum = 1;
	ptlv.tlv_buf[0].tag = EX30_TAG_SCRPRAM; 
	ptlv.tlv_buf[0].len = 0x08;
	ptlv.tlv_buf[0].value[0] = 0x60;	// 96
	ptlv.tlv_buf[0].value[1] = 0x00;	// 
	ptlv.tlv_buf[0].value[2] = 0x20;	// 32
	ptlv.tlv_buf[0].value[3] = 0x00;	// 
	ptlv.tlv_buf[0].value[4] = 0x01;	// 单基色
	ptlv.tlv_buf[0].value[5] = 0x00;	// 数据极性低
	ptlv.tlv_buf[0].value[6] = 0x01;	// OE极性高
	ptlv.tlv_buf[0].value[7] = 0x41;	// 1/4扫描方式
	APP_led_full(&ptlv);

/* 
    // set ready flag to send.                                              
    led_sendbuf.length = buf - led_sendbuf.dat;                             
    led_sendbuf.valid = TRUE;                                               
                                                                            
    HAL_UART_Transmit_IT(HDL_UART_LED, led_sendbuf.dat, led_sendbuf.length);
*/
}


/* **************************************************
 fucntion:		APP_led_setlight
 input:
 output:
 describe:	set led screen parameters
***************************************************/

void APP_led_setlight(void)
{
	APP_EX30_TypeDef ptlv;
	//uint8_t* buf = led_sendbuf.dat;
	//uint32_t length;

	// ------------ start of update ---------------
	ptlv.len = 0x000a;
	ptlv.serial = led_stat.packnum++;
	ptlv.type = EX30_TYPE;
	ptlv.cmd = EX30_CMD_WR;
	ptlv.tlvnum = 1;
	ptlv.tlv_buf[0].tag = EX30_TAG_LIGHT; 
	ptlv.tlv_buf[0].len = 0x02;
	ptlv.tlv_buf[0].value[0] = 0x00;	// 
	ptlv.tlv_buf[0].value[1] = 0x0e;	// 14
	APP_led_full(&ptlv);

/* 
    // set ready flag to send.                                              
    led_sendbuf.length = buf - led_sendbuf.dat;                             
    led_sendbuf.valid = TRUE;                                               
                                                                            
    HAL_UART_Transmit_IT(HDL_UART_LED, led_sendbuf.dat, led_sendbuf.length);
*/
}

/* **************************************************
 fucntion:		APP_led_del
 input:
 output:
 describe:	send delete program frame
***************************************************/

void APP_led_del(uint8_t del_type, uint8_t prgm_id, uint8_t part_id, uint8_t item_id)
{
	APP_EX30_TypeDef ptlv;
	//uint8_t* buf = led_sendbuf.dat;
	//uint32_t length;

	// ------------ start of update ---------------
	ptlv.len = 0x0a;
	ptlv.serial = led_stat.packnum++;
	ptlv.type = EX30_TYPE;
	ptlv.cmd = EX30_CMD_WR;
	ptlv.tlvnum = 1;
	ptlv.tlv_buf[0].tag = EX30_TAG_DEL;
	switch (del_type)
	{
	case TAG_DEL_PRGM:
		ptlv.tlv_buf[0].len = 0x02;
		ptlv.tlv_buf[0].value[0] = TAG_DEL_PRGM;	// delete program
		ptlv.tlv_buf[0].value[1] = prgm_id;	// program ID
		break;
	case TAG_DEL_PART:
		ptlv.tlv_buf[0].len = 0x03;
		ptlv.tlv_buf[0].value[0] = TAG_DEL_PART;	// delete program
		ptlv.tlv_buf[0].value[1] = prgm_id;	// program ID
		ptlv.tlv_buf[0].value[2] = part_id; // part ID
		ptlv.len += 1;
		break;
	case TAG_DEL_ITEM:
		ptlv.tlv_buf[0].len = 0x04;
		ptlv.tlv_buf[0].value[0] = TAG_DEL_ITEM;    // delete program
		ptlv.tlv_buf[0].value[1] = prgm_id;	// program ID
		ptlv.tlv_buf[0].value[2] = part_id; // part ID
		ptlv.tlv_buf[0].value[3] = item_id;	// playitem ID
		ptlv.len += 2;
		break;
	default:
		break;
	}
	APP_led_full(&ptlv);
}

/* **************************************************
 fucntion:		APP_led_delallprgm
 input:
 output:
 describe:	delete all program
***************************************************/
void APP_led_delallprgm(void)
{
	APP_led_del(TAG_DEL_PRGM, PRGRM_ALL, 0, 0);
}

/* **************************************************
 fucntion:		APP_led_pmdel
 input:
 output:
 describe:	send delete pm2.5&pm10 program frame
***************************************************/
void APP_led_pmdel(void)
{
	APP_led_del(TAG_DEL_PRGM, PRGRM_PM, 0, 0);
}
void APP_led_pmtxtdel(void)
{
	APP_led_del(TAG_DEL_ITEM, PRGRM_PM, 1, 0); 
}

/* **************************************************
 fucntion:		APP_led_htdel
 input:
 output:
 describe:	send delete humidity&temperature program frame
***************************************************/
void APP_led_thdel(void)
{
	APP_led_del(TAG_DEL_PRGM, PRGRM_TH, 0, 0); 
}
void APP_led_thtxtdel(void)
{
	APP_led_del(TAG_DEL_ITEM, PRGRM_TH, 1, 0); 
}

/* **************************************************
 fucntion:		APP_led_wndel
 input:
 output:
 describe:	send delete wind speed&noise program frame
***************************************************/

void APP_led_wndel(void)
{
	APP_led_del(TAG_DEL_PRGM, PRGRM_WN, 0, 0);
}
void APP_led_wntxtdel(void)
{
	APP_led_del(TAG_DEL_ITEM, PRGRM_WN, 1, 0); 
}
/* **************************************************
 fucntion:		APP_led_mfrdel
 input:
 output:
 describe:	send delete mfr logo program frame
***************************************************/

void APP_led_mfrdel(void)
{
	APP_led_del(TAG_DEL_PRGM, PRGRM_MFR, 0, 0);
}
void APP_led_mfrtxtdel(void)
{
	APP_led_del(TAG_DEL_ITEM, PRGRM_MFR, 1, 0); 
}

/* **************************************************
 fucntion:		APP_led_opt
 input:
 output:
 describe:	send play option frame
***************************************************/
void APP_led_opt(APP_ProgramOption_TypeDef *ptr)
{
	APP_EX30_TypeDef ptlv;
	//uint8_t* buf = led_sendbuf.dat;
	//uint32_t length;

	// ------------ start of update ---------------
	ptlv.len = 0x38;
	ptlv.serial = led_stat.packnum++;
	ptlv.type = EX30_TYPE;
	ptlv.cmd = EX30_CMD_WR;
	ptlv.tlvnum = 8;

	// program ID
	ptlv.tlv_buf[0].tag = EX30_TAG_PRGRMID; 
	ptlv.tlv_buf[0].len = 0x01;
	ptlv.tlv_buf[0].value[0] = ptr->programid;    // program ID number
	// save mode
	ptlv.tlv_buf[1].tag = EX30_TAG_SAV; 
	ptlv.tlv_buf[1].len = 0x00;
	ptlv.tlv_buf[1].value[0] = 0x01;	// save in flash
	// program propty
	ptlv.tlv_buf[2].tag = EX30_TAG_PRGRMATTR; 
	ptlv.tlv_buf[2].len = 0x03;
	ptlv.tlv_buf[2].value[0] = 0x00;	// play program in times
	ptlv.tlv_buf[2].value[1] = 0x01;	// play times
	ptlv.tlv_buf[2].value[2] = 0x00;	// second
	// interval control
	ptlv.tlv_buf[3].tag = EX30_TAG_TIMCTRL;
	ptlv.tlv_buf[3].len = 0x0b;
	ptlv.tlv_buf[3].value[0] = 0x00;	// program period
	ptlv.tlv_buf[3].value[1] = 0xD0;
	ptlv.tlv_buf[3].value[2] = 0x07;	// 2007
	ptlv.tlv_buf[3].value[3] = 0x01;	// january
	ptlv.tlv_buf[3].value[4] = 0x01;	// 1st
	ptlv.tlv_buf[3].value[5] = 0x83;	
	ptlv.tlv_buf[3].value[6] = 0x08;	// 2179
	ptlv.tlv_buf[3].value[7] = 0x06;	// june
	ptlv.tlv_buf[3].value[8] = 0x05;	// 5th
	ptlv.tlv_buf[3].value[9] = 0x7F;	// monday~sunday
	ptlv.tlv_buf[3].value[10] = 0x00;	// period number
	// partition ID 0
	ptlv.tlv_buf[4].tag = EX30_TAG_PARTID; 
	ptlv.tlv_buf[4].len = 0x01; 
	ptlv.tlv_buf[4].value[0] = 0x00;	// partition ID number
	// partition attribution
	ptlv.tlv_buf[5].tag = EX30_TAG_PARTATTR; 
	ptlv.tlv_buf[5].len = 0x08; 
	ptlv.tlv_buf[5].value[0] = 0x00;	// X axis
	ptlv.tlv_buf[5].value[1] = 0x00;
	ptlv.tlv_buf[5].value[2] = 0x00;	// Y axis
	ptlv.tlv_buf[5].value[3] = 0x00;
	ptlv.tlv_buf[5].value[4] = 0x60;	// width 96
	ptlv.tlv_buf[5].value[5] = 0x00;
	ptlv.tlv_buf[5].value[6] = 0x20;	// height 32
	ptlv.tlv_buf[5].value[7] = 0x00;
	// partition ID 1
	ptlv.tlv_buf[6].tag = EX30_TAG_PARTID; 
	ptlv.tlv_buf[6].len = 0x01; 
	ptlv.tlv_buf[6].value[0] = 0x01;	// partition ID number
	// partition attribution
	ptlv.tlv_buf[7].tag = EX30_TAG_PARTATTR; 
	ptlv.tlv_buf[7].len = 0x08;
	ptlv.tlv_buf[7].value[0] = ptr->x & 0xff;    // X axis
	ptlv.tlv_buf[7].value[1] = (ptr->x >> 8) & 0xff; 
	ptlv.tlv_buf[7].value[2] = ptr->y & 0xff;    // Y axis
	ptlv.tlv_buf[7].value[3] = (ptr->y >> 8) & 0xff; 
	ptlv.tlv_buf[7].value[4] = ptr->width & 0xff;  // width
	ptlv.tlv_buf[7].value[5] = (ptr->width >> 8) & 0xff; 
	ptlv.tlv_buf[7].value[6] = ptr->height & 0xff; // height
	ptlv.tlv_buf[7].value[7] = (ptr->height >> 8) & 0xff; 

	APP_led_full(&ptlv);
}

/* **************************************************
 fucntion:		APP_led_pmopt
 input:
 output:
 describe:	send pm2.5&pm10 srt play option frame
***************************************************/
void APP_led_pmopt(void)
{
	APP_ProgramOption_TypeDef program_opt;

	program_opt.programid = PRGRM_PM;
	program_opt.x = TXT_PM_X;
	program_opt.y = TXT_PM_Y;
	program_opt.width = TXT_PM_W;
	program_opt.height = TXT_PM_H;

	APP_led_opt(&program_opt);
}

/* **************************************************
 fucntion:		APP_led_thopt
 input:
 output:
 describe:	send temperature&humidity srt play option frame
***************************************************/
void APP_led_thopt(void)
{
	APP_ProgramOption_TypeDef program_opt;

	program_opt.programid = PRGRM_TH;
	program_opt.x = TXT_TH_X;
	program_opt.y = TXT_TH_Y;
	program_opt.width = TXT_TH_W;
	program_opt.height = TXT_TH_H;

	APP_led_opt(&program_opt);
}

/* **************************************************
 fucntion:		APP_led_wnopt
 input:
 output:
 describe:	send windspeed & noise srt play option frame
***************************************************/
void APP_led_wnopt(void)
{
	APP_ProgramOption_TypeDef program_opt;

	program_opt.programid = PRGRM_WN;
	program_opt.x = TXT_WN_X;
	program_opt.y = TXT_WN_Y;
	program_opt.width = TXT_WN_W;
	program_opt.height = TXT_WN_H;

	APP_led_opt(&program_opt);
}

/* **************************************************
 fucntion:		APP_led_mfropt
 input:
 output:
 describe:	send manufactory srt play option frame
***************************************************/
void APP_led_mfropt(void)
{
	APP_ProgramOption_TypeDef program_opt;

	program_opt.programid = PRGRM_MFR; 
	program_opt.x = TXT_MFR_X;
	program_opt.y = TXT_MFR_Y;
	program_opt.width = TXT_MFR_W;
	program_opt.height = TXT_MFR_H;

	APP_led_opt(&program_opt);
}

/* **************************************************
 fucntion:		APP_led_srt
 input:
 output:
 describe:	send subtitle frame
***************************************************/
void APP_led_srt(uint8_t prgm_id,uint8_t *pdata)
{
	APP_EX30_TypeDef ptlv;
	//uint8_t* buf = led_sendbuf.dat;
	//uint32_t length;

	// ------------ start of update ---------------
	ptlv.len = 0x1BB;	//	443
	ptlv.serial = led_stat.packnum++;
	ptlv.type = EX30_TYPE;
	ptlv.cmd = EX30_CMD_WR;
	ptlv.tlvnum = 9;

	// program ID
	ptlv.tlv_buf[0].tag = EX30_TAG_PRGRMID; 
	ptlv.tlv_buf[0].len = 0x01;
	ptlv.tlv_buf[0].value[0] = prgm_id;	// program ID number
	// partition ID 0
	ptlv.tlv_buf[1].tag = EX30_TAG_PARTID;
	ptlv.tlv_buf[1].len = 0x01;
	ptlv.tlv_buf[1].value[0] = 0x00;	// partition ID number
	// play item ID 0
	ptlv.tlv_buf[2].tag = EX30_TAG_PLAYITEMID; 
	ptlv.tlv_buf[2].len = 0x01;
	ptlv.tlv_buf[2].value[0] = 0x00;	// play item ID number
	// data packet property
	ptlv.tlv_buf[3].tag = EX30_TAG_PACKETATTR; 
	ptlv.tlv_buf[3].len = 0x06;
	ptlv.tlv_buf[3].value[0] = 0x01;	// total packet number
	ptlv.tlv_buf[3].value[1] = 0x00;
	ptlv.tlv_buf[3].value[2] = 0x00;	// current packet number
	ptlv.tlv_buf[3].value[3] = 0x00;	
	ptlv.tlv_buf[3].value[4] = 0x00;	// packet length 1024
	ptlv.tlv_buf[3].value[5] = 0x04;	
	// save mode
	ptlv.tlv_buf[4].tag = EX30_TAG_SAV; 
	ptlv.tlv_buf[4].len = 0x00;
	ptlv.tlv_buf[4].value[0] = 0x01;	// save in flash
	// play item special effect
	ptlv.tlv_buf[5].tag = EX30_TAG_PLAYITEMSPEC;
	ptlv.tlv_buf[5].len = 0x03; 
	ptlv.tlv_buf[5].value[0] = 0x01;	// immediately display
	ptlv.tlv_buf[5].value[1] = 0x09;	// specail effect grade
	ptlv.tlv_buf[5].value[2] = 0x05;	// stay 5 seconds
	// play item attribution
	ptlv.tlv_buf[6].tag = EX30_TAG_PLAYITEMATTR; 
	ptlv.tlv_buf[6].len = 0x10; 
	ptlv.tlv_buf[6].value[0] = 0x00;	// 定次播放
	ptlv.tlv_buf[6].value[1] = 0x01;	// 播放次数
	ptlv.tlv_buf[6].value[2] = 0x00;	
	ptlv.tlv_buf[6].value[3] = 0x01;	// 图片
	ptlv.tlv_buf[6].value[4] = 0x00;	// 数据组织方式
	ptlv.tlv_buf[6].value[5] = 0x01;	// 单基色图片
	ptlv.tlv_buf[6].value[6] = 0x60;	// width 96
	ptlv.tlv_buf[6].value[7] = 0x00;	
	ptlv.tlv_buf[6].value[8] = 0x20;	// height 32
	ptlv.tlv_buf[6].value[9] = 0x00;	
	ptlv.tlv_buf[6].value[10] = 0x01;	// 图片页数 1
	ptlv.tlv_buf[6].value[11] = 0x00;	
	ptlv.tlv_buf[6].value[12] = 0xFF;	// 非GIF
	ptlv.tlv_buf[6].value[13] = 0xFF;	
	ptlv.tlv_buf[6].value[14] = 0x00;	// 最后一页字幕有效长度
	ptlv.tlv_buf[6].value[15] = 0x00;	
	// 实时刷新
	ptlv.tlv_buf[7].tag = EX30_TAG_UPDAT;
	ptlv.tlv_buf[7].len = 0x04;
	ptlv.tlv_buf[7].value[0] = 0x02;	// play item
	ptlv.tlv_buf[7].value[1] = 0x00;	// program ID 0
	ptlv.tlv_buf[7].value[2] = 0x00;	// partition ID 0
	ptlv.tlv_buf[7].value[3] = 0x00;	// play item ID 0
	// data packet
	ptlv.tlv_buf[8].tag = EX30_TAG_PACKET;
	ptlv.tlv_buf[8].len = 0x180;		// 384
	for (uint16_t i = 0; i < ptlv.tlv_buf[8].len; i++)
	{
		ptlv.tlv_buf[8].value[i] = pdata[i];
	}

	APP_led_full(&ptlv);
}

/* **************************************************
 fucntion:		APP_led_pmsrt
 input:
 output:
 describe:	send pm2.5&pm10 subtitle frame
***************************************************/
void APP_led_pmsrt(void)
{
	APP_led_srt(PRGRM_PM, (uint8_t *)SRT_PM);
}

/* **************************************************
 fucntion:		APP_led_thsrt
 input:
 output:
 describe:	send temperature&humidity subtitle frame
***************************************************/
void APP_led_thsrt(void)
{
	APP_led_srt(PRGRM_TH, (uint8_t *)SRT_TH);
}

/* **************************************************
 fucntion:		APP_led_wnsrt
 input:
 output:
 describe:	send windspeed & noise subtitle frame
***************************************************/
void APP_led_wnsrt(void)
{
	APP_led_srt(PRGRM_WN, (uint8_t *)SRT_WIND_NOISE);
}

/* **************************************************
 fucntion:		APP_led_mfrsrt
 input:
 output:
 describe:	send company name subtitle frame
***************************************************/
void APP_led_mfrsrt(void)
{
	APP_led_srt(PRGRM_MFR, (uint8_t *)SRT_MFR);
}

/* **************************************************
 fucntion:		APP_led_pmtxt
 input:
 output:
 describe:	send pm txt frame
***************************************************/

void APP_led_txt(uint8_t prgm_id, uint8_t *str)
{
	APP_EX30_TypeDef ptlv;
	//uint8_t* buf = led_sendbuf.dat;
	uint16_t length;

	// ------------ start of update ---------------
	length = (uint16_t)strlen((const char *)str);
	ptlv.len = 0x33 + length; 
	ptlv.serial = led_stat.packnum++;
	ptlv.type = EX30_TYPE;
	ptlv.cmd = EX30_CMD_WR;
	ptlv.tlvnum = 9;

	// program ID
	ptlv.tlv_buf[0].tag = EX30_TAG_PRGRMID; 
	ptlv.tlv_buf[0].len = 0x01;
	ptlv.tlv_buf[0].value[0] = prgm_id;	// program ID number
	// partition ID 0
	ptlv.tlv_buf[1].tag = EX30_TAG_PARTID;
	ptlv.tlv_buf[1].len = 0x01;
	ptlv.tlv_buf[1].value[0] = 0x01;	// partition ID number
	// play item ID 0
	ptlv.tlv_buf[2].tag = EX30_TAG_PLAYITEMID; 
	ptlv.tlv_buf[2].len = 0x01;
	ptlv.tlv_buf[2].value[0] = 0x00;	// play item ID number
	// data packet property
	ptlv.tlv_buf[3].tag = EX30_TAG_PACKETATTR; 
	ptlv.tlv_buf[3].len = 0x06;
	ptlv.tlv_buf[3].value[0] = 0x01;	// total packet number
	ptlv.tlv_buf[3].value[1] = 0x00;
	ptlv.tlv_buf[3].value[2] = 0x00;	// current packet number
	ptlv.tlv_buf[3].value[3] = 0x00;	
	ptlv.tlv_buf[3].value[4] = 0x00;	// packet length 1024
	ptlv.tlv_buf[3].value[5] = 0x04;	
	// save mode
	ptlv.tlv_buf[4].tag = EX30_TAG_SAV; 
	ptlv.tlv_buf[4].len = 0x01;
	ptlv.tlv_buf[4].value[0] = 0x00;	// save in flash
	// play item special effect
	ptlv.tlv_buf[5].tag = EX30_TAG_PLAYITEMSPEC;
	ptlv.tlv_buf[5].len = 0x03; 
	ptlv.tlv_buf[5].value[0] = 0x01;	// immediately display
	ptlv.tlv_buf[5].value[1] = 0x09;	// specail effect grade
	ptlv.tlv_buf[5].value[2] = 0x05;	// stay 5 seconds
	// play item attribution
	ptlv.tlv_buf[6].tag = EX30_TAG_PLAYITEMATTR; 
	ptlv.tlv_buf[6].len = 0x0A; 
	ptlv.tlv_buf[6].value[0] = 0x00;	// 定次播放
	ptlv.tlv_buf[6].value[1] = 0x01;	// 播放次数
	ptlv.tlv_buf[6].value[2] = 0x00;	
	ptlv.tlv_buf[6].value[3] = 0x00;	// 文本
	ptlv.tlv_buf[6].value[4] = 0x00;	// GB2312
	ptlv.tlv_buf[6].value[5] = 0x10;	// 字体大小16
	ptlv.tlv_buf[6].value[6] = 0x01;	// 红色
	ptlv.tlv_buf[6].value[7] = 0x00;	// 字体0（宋体）
	ptlv.tlv_buf[6].value[8] = 0x00;	// 文本连续移动时首尾相连距离
	ptlv.tlv_buf[6].value[9] = 0x00;	
	// 实时刷新
	ptlv.tlv_buf[7].tag = EX30_TAG_UPDAT;
	ptlv.tlv_buf[7].len = 0x04;
	ptlv.tlv_buf[7].value[0] = 0x02;	// play item
	ptlv.tlv_buf[7].value[1] = prgm_id;    // program ID 0
	ptlv.tlv_buf[7].value[2] = 0x01;	// partition ID 1
	ptlv.tlv_buf[7].value[3] = 0x00;	// play item ID 0
	// data packet
	ptlv.tlv_buf[8].tag = EX30_TAG_PACKET;
	ptlv.tlv_buf[8].len = length;      // 7
	// 此处添加字符串
	for (uint16_t i = 0; i < length; i++)
	{
		ptlv.tlv_buf[8].value[i] = str[i];
	}

	APP_led_full(&ptlv);
}

/* **************************************************
 fucntion:		APP_led_pmtxt
 input:
 output:
 describe:	send pm2.5 & pm10 txt frame
***************************************************/
void APP_led_pmtxt(void)
{
	uint8_t pmstr[10];
	//	
	APP_led_pmf2a(sensor_value[SENS_PM25].value, sensor_value[SENS_PM10].value, pmstr);
	APP_led_txt(PRGRM_PM, pmstr);
}

/* **************************************************
 fucntion:		APP_led_thtxt
 input:
 output:
 describe:	send temperature & humidity txt frame
***************************************************/
void APP_led_thtxt(void)
{
	uint8_t thstr[10];
	//	
	APP_led_thf2a(sensor_value[SENS_TEMP].value, sensor_value[SENS_HMDT].value, thstr); 
	//APP_led_thf2a(temperature, humidity, thstr); 
	APP_led_txt(PRGRM_TH, thstr);
}

/* **************************************************
 fucntion:		APP_led_wntxt
 input:
 output:
 describe:	send windspeed & noise txt frame
***************************************************/
void APP_led_wntxt(void)
{
	uint8_t wnstr[10];
	//	
	APP_led_wnf2a(sensor_value[SENS_WIND].value,35 * log10(0.00523*sensor_value[SENS_NOISE].value+4.708) + 25, wnstr); 
	APP_led_txt(PRGRM_WN, wnstr);
}

/* **************************************************
 fucntion:		APP_led_task
 input:
 output:
 describe:	led task
***************************************************/
void APP_led_task_noise(void)
{
	enum
	{
		LED_STEP_LINK = 0, // communicate with ex-30
		LED_STEP_SETSRC,	// set screen parameter
		LED_STEP_SETLIGHT,	// set lightness
		LED_STEP_PMDEL,  // delete program for pm screen
		LED_STEP_PMOPT,  // set pm screen option
		LED_STEP_PMSCR,  // send pm2.5&pm1.0 subtitle screen
		LED_STEP_THDEL,   // delete program for temperature & humidity screen
		LED_STEP_THOPT,  // set temperature & humidity screen option
		LED_STEP_THSCR,  // send temperature & humidity subtitle screen
		LED_STEP_WNDEL,  // delete program for wind speed&noise screen
		LED_STEP_WNOPT,  // set wind speed&noise screen option
		LED_STEP_WNSCR,  // send wind speed&noise subtitle screen
		LED_STEP_MFRDEL,
		LED_STEP_MFROPT,
		LED_STEP_MFRSCR,	// send manufactory screen
		LED_STEP_DELPMTXT,
		LED_STEP_PMTXT,  // display pm2.5&pm10 data
		LED_STEP_DELTHTXT,
		LED_STEP_THTXT,  // display temperature & humidity data
		LED_STEP_DELWLTXT,
		LED_STEP_WNTXT,  // display wind speed&noise data
		LED_STEP_DELAY15,

		LED_STEP_MAX
	};

	static uint8_t step = LED_STEP_LINK;
	static uint32_t timestamp = 0,cnt = 0;
	uint32_t tick;
	tick = HAL_GetTick();
/* 
	if ((tick - timestamp) > 5000)
	{
		step = LED_STEP_LINK;
		led_sendbuf.busy = FALSE;
		led_stat.packnum = 0;
	}
	timestamp = tick;
*/
	if (led_sendbuf.busy)
	{
        cnt++;                 
        if (cnt >= 100)        
        {                            
            cnt = 0;           
			//step = LED_STEP_LINK;
			led_sendbuf.busy = FALSE;
			//led_stat.packnum = 0;
        }                            
		return;
	}
	else cnt = 0;

	switch (step)
	{
	case LED_STEP_LINK:
		APP_led_connect();
		step = LED_STEP_SETSRC; 
		break;
	case LED_STEP_SETSRC:
		APP_led_setsrccfg(); 
		step = LED_STEP_SETLIGHT; 
		break;
	case LED_STEP_SETLIGHT:
		APP_led_setlight(); 
		step = LED_STEP_PMDEL;
		break;
	case LED_STEP_PMDEL:
		APP_led_pmdel();
		step = LED_STEP_PMOPT;
		break;
	case LED_STEP_PMOPT:
		APP_led_pmopt();
		step = LED_STEP_PMSCR;
		break;
	case LED_STEP_PMSCR:
		APP_led_pmsrt();
		step = LED_STEP_THDEL;
		break;
	case LED_STEP_THDEL:
		APP_led_thdel();
		step = LED_STEP_THOPT;
		break;
	case LED_STEP_THOPT:
		APP_led_thopt();
		step = LED_STEP_THSCR;
		break;
	case LED_STEP_THSCR:
		APP_led_thsrt();
		step = LED_STEP_WNDEL;
		break;
	case LED_STEP_WNDEL:
		APP_led_wndel();
		step = LED_STEP_WNOPT;
		break;
	case LED_STEP_WNOPT:
		APP_led_wnopt();
		step = LED_STEP_WNSCR;
		break;
	case LED_STEP_WNSCR:
		APP_led_wnsrt();
		step = LED_STEP_MFRDEL;
		break;
	case LED_STEP_MFRDEL:
		APP_led_mfrdel();
		step = LED_STEP_MFROPT;
		break;
	case LED_STEP_MFROPT:
		APP_led_mfropt();
		step = LED_STEP_MFRSCR;
		break;
	case LED_STEP_MFRSCR:
		APP_led_mfrsrt();
		step = LED_STEP_DELPMTXT;
		break;
	case LED_STEP_DELPMTXT:
		APP_led_pmtxtdel();
		step = LED_STEP_PMTXT;
		break;
	case LED_STEP_PMTXT:
		if (sensor_value[SENS_PM25].valid && sensor_value[SENS_PM10].valid) 
		{
			APP_led_pmtxt();
		}
		step = LED_STEP_DELTHTXT;
		break;
	case LED_STEP_DELTHTXT:
		APP_led_thtxtdel();
		step = LED_STEP_THTXT;
		break;
	case LED_STEP_THTXT:
		if (sensor_value[SENS_TEMP].valid && sensor_value[SENS_HMDT].valid) 
		{
			APP_led_thtxt();
		}
		step = LED_STEP_DELWLTXT;
		break;
	case LED_STEP_DELWLTXT:
		APP_led_wntxtdel();
		step = LED_STEP_WNTXT;
		break;
	case LED_STEP_WNTXT:
		if (sensor_value[SENS_WIND].valid)
		{
			APP_led_wntxt();
		}
		step = LED_STEP_DELAY15;
		timestamp = tick;
		break; 
	case LED_STEP_DELAY15:
		if ((tick - timestamp) > 15000)
		{
			step = LED_STEP_DELPMTXT;
		}
		break;
	default:
		step = LED_STEP_LINK;
		led_sendbuf.busy = FALSE;
		led_stat.packnum = 0;

		break;
	}
}

void APP_led_task(void)
{
	enum
	{
		LED_STEP_LINK = 0  	,// communicate with ex-30
		LED_STEP_SETSRC 	,// set screen parameter
		LED_STEP_SETLIGHT   ,// set lightness
		LED_STEP_DELALLPRGM ,// delete all program
		LED_STEP_PMDEL  	,// delete program for pm screen     
		LED_STEP_PMOPT  	,// set pm screen option             
		LED_STEP_PMSCR  	,// send pm2.5&pm1.0 subtitle screen 
		LED_STEP_PMTXT  	,// display pm2.5&pm10 data
		LED_STEP_THDEL  	,// delete program for temperature & humidity screen
		LED_STEP_THOPT  	,// set temperature & humidity screen option        
		LED_STEP_THSCR  	,// send temperature & humidity subtitle screen     
		LED_STEP_THTXT  	,// display temperature & humidity data
		LED_STEP_WLDEL  	,// delete program for wind speed screen
		LED_STEP_WLOPT  	,// set wind speed screen option        
		LED_STEP_WLSCR  	,// send wind speed subtitle screen     
		LED_STEP_WLTXT  	,// display wind speed data
		LED_STEP_DELPMTXT   ,
		LED_STEP_PMTXT1 	,
		LED_STEP_DELTHTXT   ,
		LED_STEP_THTXT1 	,
		LED_STEP_DELWLTXT   ,
		LED_STEP_WLTXT1 	,
		LED_STEP_DELAY15	,
		LED_STEP_MAX		
	};

	static uint8_t step = LED_STEP_LINK;
	static uint32_t timestamp = 0,cnt = 0;
	uint32_t tick;
	tick = HAL_GetTick();
/* 
	if ((tick - timestamp) > 5000)
	{
		step = LED_STEP_LINK;
		led_sendbuf.busy = FALSE;
		led_stat.packnum = 0;
	}
	timestamp = tick;
*/
	if (led_sendbuf.busy)
	{
        cnt++;                 
        if (cnt >= 100)        
        {                            
            cnt = 0;           
			step = LED_STEP_LINK;
			led_sendbuf.busy = FALSE;
			led_stat.packnum = 0;
        }                            
		return;
	}
	else cnt = 0;

	switch (step)
	{
	case LED_STEP_LINK:
		APP_led_connect();
		step = LED_STEP_SETSRC; 
		break;
	case LED_STEP_SETSRC:
		APP_led_setsrccfg(); 
		step = LED_STEP_SETLIGHT; 
		break;
	case LED_STEP_SETLIGHT:
		APP_led_setlight(); 
		step = LED_STEP_DELALLPRGM;
		break;
	case LED_STEP_DELALLPRGM:
		APP_led_delallprgm();
		step = LED_STEP_PMDEL;
		break;
	case LED_STEP_PMDEL:
		APP_led_pmdel();
		step = LED_STEP_PMOPT;
		break;
	case LED_STEP_PMOPT:
		APP_led_pmopt();
		step = LED_STEP_PMSCR;
		break;
	case LED_STEP_PMSCR:
		APP_led_pmsrt();
		step = LED_STEP_PMTXT;
		break;
	case LED_STEP_PMTXT:
		//if (sensor_value[SENS_PM25].valid && sensor_value[SENS_PM10].valid) 
		{
			APP_led_pmtxt();
		}
		step = LED_STEP_THDEL;
		break;
	case LED_STEP_THDEL:
		APP_led_thdel();
		step = LED_STEP_THOPT;
		break;
	case LED_STEP_THOPT:
		APP_led_thopt();
		step = LED_STEP_THSCR;
		break;
	case LED_STEP_THSCR:
		APP_led_thsrt();
		step = LED_STEP_THTXT;
		break;
	case LED_STEP_THTXT:
		//if (sensor_value[SENS_TEMP].valid && sensor_value[SENS_HMDT].valid) 
		{
			APP_led_thtxt();
		}
		step = LED_STEP_WLDEL;
		break;
	case LED_STEP_WLDEL:
		APP_led_wldel();
		step = LED_STEP_WLOPT;
		break;
	case LED_STEP_WLOPT:
		APP_led_wlopt();
		step = LED_STEP_WLSCR;
		break;
	case LED_STEP_WLSCR:
		APP_led_wlsrt();
		step = LED_STEP_WLTXT;
		break;
	case LED_STEP_WLTXT:
		//if (sensor_value[SENS_WIND].valid)
		{
			APP_led_wltxt();
		}
		step = LED_STEP_DELPMTXT;
		timestamp = tick;
		break; 
	case LED_STEP_DELPMTXT:
		APP_led_pmtxtdel();
		step = LED_STEP_PMTXT1;
		break;
	case LED_STEP_PMTXT1:
		APP_led_pmtxt();
		step = LED_STEP_DELTHTXT;
		break;
	case LED_STEP_DELTHTXT:
		APP_led_thtxtdel();
		step = LED_STEP_THTXT1;
		break;
	case LED_STEP_THTXT1:
		APP_led_thtxt();
		step = LED_STEP_DELWLTXT;
		break;

	case LED_STEP_DELWLTXT:
		APP_led_wltxtdel();
		step = LED_STEP_WLTXT1;
		break;
	case LED_STEP_WLTXT1:
		APP_led_wltxt();
		step = LED_STEP_DELAY15;
		break;
	case LED_STEP_DELAY15:
		if ((tick - timestamp) > 15000)
		{
			step = LED_STEP_DELPMTXT;
		}
		break;
	default:
		step = LED_STEP_LINK;
		led_sendbuf.busy = FALSE;
		led_stat.packnum = 0;

		break;
	}
}

/* **************************************************
 fucntion:		APP_led_pmf2a
 input:
 output:
 describe:	translate pm value to ascii
***************************************************/

void APP_led_pmf2a(float pm25_dat, float pm10_dat, uint8_t *buf)
{
	uint8_t asc[10];
	static uint32_t temp;

	temp = (pm25_dat > 999)? 999 : pm25_dat;
	
	asc[0] =  (temp /100);
	asc[1] =  (temp / 10 % 10);
	asc[2] =  (temp % 10);

	if (asc[0] == 0)
	{
		*buf++ = 0x20;
	}
	else *buf++ = asc[0] + 0x30;

	if (asc[0] == 0 && asc[1] == 0)
	{
		*buf++ = 0x20;
	}
	else *buf++ = asc[1] + 0x30;

	*buf++ = asc[2] + 0x30;

	*buf++ = 0x20;
		
	temp = (pm10_dat > 999)? 999 : pm10_dat;
	
	asc[0] =  (temp /100);
	asc[1] =  (temp /10 % 10);
	asc[2] =  (temp % 10);

	if (asc[0] == 0)
	{
		*buf++ = 0x20;
	}
	else *buf++ = asc[0] + 0x30;

	if (asc[0] == 0 && asc[1] == 0)
	{
		*buf++ = 0x20;
	}
	else *buf++ = asc[1] + 0x30;

	*buf++ = asc[2] + 0x30;

	*buf = 0;	
}


/* **************************************************
 fucntion:		APP_led_thf2a
 input:
 output:
 describe:	translate temperatrue & humidity value to ascii
***************************************************/

void APP_led_thf2a(float v_temp, float v_humi, uint8_t *buf)
{
	uint8_t asc[10];
	static uint32_t temp;
	float tv,hv;

	tv = v_temp*10.0f;
	temp = (tv > 999)? 999 : tv;
	
	asc[0] =  (temp /100);
	asc[1] =  (temp / 10 % 10);
	asc[2] =  (temp % 10);

	if (asc[0] == 0)
	{
		*buf++ = 0x20;
	}
	else *buf++ = asc[0] + 0x30;

	*buf++ = asc[1] + 0x30;

	*buf++ = '.';

	*buf++ = asc[2] + 0x30;

	hv = v_humi * 10.0f; 
	temp = (hv > 999)? 999 : hv;

	asc[0] =  (temp /100);
	asc[1] =  (temp /10 % 10);
	asc[2] =  (temp % 10);

	if (asc[0] == 0)
	{
		*buf++ = 0x20;
	}
	else *buf++ = asc[0] + 0x30;

	*buf++ = asc[1] + 0x30;

	*buf++ = '.';

	*buf++ = asc[2] + 0x30;

	*buf = 0;	
}


/* **************************************************
 fucntion:		APP_led_wnf2a
 input:
 output:
 describe:	translate wind speed&noise value to ascii
***************************************************/

void APP_led_wnf2a(float windspeed, float noise, uint8_t *buf)
{
	uint8_t asc[10];
	static uint32_t temp;
	float ws,ns;

	ws = windspeed*10.0f;
	temp = (ws > 999)? 999 : ws;

	asc[0] =  (temp /100);
	asc[1] =  (temp /10 % 10);
	asc[2] =  (temp % 10);

	if (asc[0] == 0)
	{
		*buf++ = 0x20;
	}
	else *buf++ = asc[0] + 0x30;

    *buf++ = asc[1] + 0x30;

	*buf++ = '.';

	*buf++ = asc[2] + 0x30;

	ns = noise * 10.0f; 
	temp = (ns > 999)? 999 : ns;

	asc[0] =  (temp /100);
	asc[1] =  (temp /10 % 10);
	asc[2] =  (temp % 10);

	if (asc[0] == 0)
	{
		*buf++ = 0x20;
	}
	else *buf++ = asc[0] + 0x30;

	*buf++ = asc[1] + 0x30;

	*buf++ = '.';

	*buf++ = asc[2] + 0x30;

	*buf = 0;	
}

/* **************************************************
 fucntion:		APP_led_wldel
 input:
 output:
 describe:	send delete wind speed&company logo program frame
***************************************************/

void APP_led_wldel(void)
{
	APP_led_del(TAG_DEL_PRGM, PRGRM_WL, 0, 0);
}
void APP_led_wltxtdel(void)
{
	APP_led_del(TAG_DEL_ITEM, PRGRM_WL, 1, 0); 
}
/* **************************************************
 fucntion:		APP_led_wlopt
 input:
 output:
 describe:	send windspeed & company name srt play option frame
***************************************************/
void APP_led_wlopt(void)
{
	APP_ProgramOption_TypeDef program_opt;

	program_opt.programid = PRGRM_WL;
	program_opt.x = TXT_WL_X;
	program_opt.y = TXT_WL_Y;
	program_opt.width = TXT_WL_W;
	program_opt.height = TXT_WL_H;

	APP_led_opt(&program_opt);
}
/* **************************************************
 fucntion:		APP_led_wlsrt
 input:
 output:
 describe:	send windspeed & company name subtitle frame
***************************************************/
void APP_led_wlsrt(void)
{
	APP_led_srt(PRGRM_WL, (uint8_t *)SRT_WIND);
}
/* **************************************************
 fucntion:		APP_led_wltxt
 input:
 output:
 describe:	send windspeed & company name txt frame
***************************************************/
void APP_led_wltxt(void)
{
	uint8_t wlstr[5];
	//	
	APP_led_wlf2a(sensor_value[SENS_WIND].value, wlstr);
	APP_led_txt(PRGRM_WL, wlstr);
}
/* **************************************************
 fucntion:		APP_led_wlf2a
 input:
 output:
 describe:	translate wind speed value to ascii
***************************************************/

void APP_led_wlf2a(float windspeed, uint8_t *buf)
{
	uint8_t asc[10];
	static uint32_t temp;
	float ws;

	ws = windspeed*10.0f;
	temp = (ws > 999)? 999 : ws;

	asc[0] =  (temp /100);
	asc[1] =  (temp /10 % 10);
	asc[2] =  (temp % 10);

	if (asc[0] == 0)
	{
		*buf++ = 0x20;
	}
	else *buf++ = asc[0] + 0x30;

    *buf++ = asc[1] + 0x30;

	*buf++ = '.';

	*buf++ = asc[2] + 0x30;

	*buf = 0;	
}
#ifdef LED_DEBUG
	#define _STATIC	static
#else
	#define _STATIC
#endif

/* ***************************   functions  **********************************/

#undef _STATIC


#undef	_LOCAL_LED

/* ****************************  END OF FILE  *********************************/

